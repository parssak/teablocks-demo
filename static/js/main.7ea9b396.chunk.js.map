{"version":3,"sources":["compiler/assemblyBlocks/shape/GetShapeBlock.ts","compiler/assemblyBlocks/shape/MakeShapeBlock.ts","codeBlocks/GuranteedRoot.ts","codeBlocks/InputNode.ts","compiler/assemblyBlocks/AbstractBlock.ts","compiler/assemblyBlocks/inputBlocks/index.ts","compiler/factory/BlockType.ts","compiler/TeaBlocksError.ts","compiler/assemblyBlocks/ReturnBlock.ts","compiler/assemblyBlocks/VoidBlock.ts","compiler/assemblyBlocks/inputBlocks/ControlType.ts","diagram/CustomSchema.ts","ide/NodeBuilder.ts","diagram/DiagramWrapper.js","diagram/UncontrolledDiagram.tsx","ide/DiagramIDE.tsx","compiler/assemblyBlocks/inputBlocks/ButtonStatusBlock.ts","compiler/assemblyBlocks/inputBlocks/JoyXStatusBlock.ts","compiler/assemblyBlocks/inputBlocks/JoyYStatusBlock.ts","diagram/renders/CustomRender.tsx","diagram/renders/IfRender.tsx","diagram/renders/WhileRender.tsx","codeBlocks/FunctionNode.ts","codeBlocks/IfNode.ts","codeBlocks/WhileNode.ts","diagram/renders/RenderHelper.js","diagram/renders/index.ts","compiler/InternalCompilerError.ts","compiler/assemblyBlocks/shape/ShapeColor.ts","compiler/assemblyBlocks/shape/GetXBlock.ts","compiler/assemblyBlocks/shape/GetYBlock.ts","compiler/assemblyBlocks/shape/MoveBlock.ts","compiler/assemblyBlocks/shape/RotateBlock.ts","compiler/assemblyBlocks/shape/ScaleBlock.ts","compiler/assemblyBlocks/shape/ShapeType.ts","compiler/Program.ts","compiler/Compiler.ts","runtime/Canvas.js","runtime/Runtime.tsx","compiler/state/StateNode.ts","ide/Precompiler.ts","serializor/SchemaSerializor.ts","ide/AppDiagram.tsx","App.tsx","reportWebVitals.ts","index.tsx","compiler/assemblyBlocks/shape/Shape.ts","codeBlocks/OutputNode.ts","compiler/assemblyBlocks/inputBlocks/ControlElement.ts","compiler/assemblyBlocks/inputBlocks/MakeControlElementBlock.ts","compiler/assemblyBlocks/outputBlocks/ConsoleLogBlock.ts","compiler/assemblyBlocks/returnBlocks/boolean/comparison/EQBlock.ts","compiler/assemblyBlocks/returnBlocks/boolean/comparison/GEQBlock.ts","compiler/assemblyBlocks/returnBlocks/boolean/comparison/GTBlock.ts","compiler/assemblyBlocks/returnBlocks/boolean/comparison/LEQBlock.ts","compiler/assemblyBlocks/returnBlocks/boolean/comparison/LTBlock.ts","compiler/assemblyBlocks/returnBlocks/boolean/operators/ANDBlock.ts","compiler/assemblyBlocks/returnBlocks/boolean/operators/NOTBlock.ts","compiler/assemblyBlocks/returnBlocks/boolean/operators/ORBlock.ts","compiler/assemblyBlocks/returnBlocks/math/DivisionBlock.ts","compiler/assemblyBlocks/returnBlocks/math/ExponentBlock.ts","compiler/assemblyBlocks/returnBlocks/math/ModuloBlock.ts","compiler/assemblyBlocks/returnBlocks/math/ProductBlock.ts","compiler/assemblyBlocks/returnBlocks/math/SubtractBlock.ts","compiler/assemblyBlocks/returnBlocks/math/SumBlock.ts","compiler/assemblyBlocks/returnBlocks/TernaryBlock.ts","compiler/assemblyBlocks/variable/VarAssignBlock.ts","compiler/assemblyBlocks/specialBlocks/FORBlock.ts","compiler/assemblyBlocks/specialBlocks/IFBlock.ts","compiler/assemblyBlocks/specialBlocks/WHILEBlock.ts","compiler/assemblyBlocks/variable/ConstBlock.ts","compiler/assemblyBlocks/variable/ArrayCreateBlock.ts","compiler/assemblyBlocks/variable/ArrayGetIndex.ts","compiler/assemblyBlocks/variable/ArraySetIndex.ts","compiler/assemblyBlocks/variable/VarDeleteBlock.ts","compiler/assemblyBlocks/variable/VarRetrieveBlock.ts","compiler/factory/BlockFactory.js","codeBlocks/index.ts"],"names":["GetShapeBlock","id","shapeName","varEnv","internalName","this","has","TeaBlocksError","ReturnBlock","MakeShapeBlock","shapeType","color","inputs","posX","posY","scaleX","scaleY","rot","console","log","String","evalBlock","posx","Number","posy","scalex","scaley","isNaN","set","Shape","VoidBlock","GuranteedRoot","isRoot","InputNode","content","coordinates","numOutputs","blockType","constInputs","data","render","outputs","DiagramIDE","getID","i","port","push","AbstractBlock","BlockType","message","name","Error","voidBlock","ControlType","FIRST_COORDINATE","CustomSchema","nodes","links","length","NodeBuilder","schemaId","parentSchemaId","getIDE","validatedSchemas","coors","get","getNextCoordinates","type","nextCoordinates","centralizeCoordinates","SUM","addFunctionNode","PROD","SUBTRACT","DIV","EQ","LT","GT","LEQ","GEQ","AND","OR","NOT","TERNARY","MOD","EXP","GET_X","GET_Y","error","CONST","cstVal","prompt","addInputNode","VAR_RETRIEVE","varName","GET_SHAPE","shapeget","JOY_X","joyxname","JOY_Y","joyyname","ARR_GET_IX","arrName","CLB","addOutputNode","VAR_ASSIGN","VAR_DELETE","varDeleteName","MAKE_SHAPE","ShapeType","RECT","ShapeColor","BLUE","ROTATE_SHAPE","MOVE_SHAPE","SCALE_SHAPE","ARR_CREATE","arrMake","ARR_SET_IX","MAKE_CONTROL_ELEM","elemType","JOYSTICK","elemName","IF","nextIf","IfNode","parentSchema","inputNames","problematic","IfRender","schemaMethods","addNode","WHILE","nextWhile","WhileNode","WhileRender","constVal","numOfOutputs","outputNames","nextNode","CustomRender","numOfInputs","OutputNode","FunctionNode","DiagramWrapper","props","schema","onChange","UncontrolledDiagram","initialSchema","useSchema","removeNode","deleteNodeFromSchema","nodeToRemove","find","node","useState","nodeBuilder","Function","makeCallback","setMakeCallback","scheduleMakeInput","callback","coor","makeInput","scheduleMakeOutput","makeOutput","scheduleMakeFunction","makeFunction","scheduleMakeSpecial","makeSpecial","useEffect","addSchema","className","onClick","e","pageX","pageY","clickMakeNode","icon","ideId","displaySchemaId","Map","globalNextId","toRender","ReactDOM","document","getElementById","leRoot","unmountComponentAtNode","renderDiagram","methods","redrawDiagram","schemas","startID","nodeId","forEach","Array","from","values","foundNode","instance","ButtonStatusBlock","buttonName","val","Boolean","JoyXStatusBlock","joyName","vName","x","JoyYStatusBlock","y","inpDivs","RenderHelper","makeInputDivs","outDivs","makeOutputDivs","size","deleteNode","setDisplaySchemaId","numInputs","ix","React","cloneElement","key","InternalCompilerError","GetXBlock","shape","GetYBlock","MoveBlock","RotateBlock","ScaleBlock","interuptSignal","Program","subroutines","triggerDict","triggeredIndexes","taskQueue","errorNotify","Set","ixArr","add","trigName","t","sub","buildTaskQueue","getLength","scheduleNextTask","filter","task","gen","stopCleanup","status","s","count","next","done","err","window","requestAnimationFrame","_","eventLoop","nextTask","shift","aaa","trees","compileTree","a","hasBeenCompiled","EvalError","isInput","compiledNode","createAssemblyBlock","trigSet","isTriggered","thisNodeChildren","children","map","childArr","child","compiledChild","trig","subroutine","Canvas","draw","rest","canvasRef","useRef","animationFrameId","canvas","current","context","getContext","frameCount","style","width","height","offsetWidth","offsetHeight","cancelAnimationFrame","ref","Runtime","program","inputStorage","state","bind","setup","inputVal","inputName","started","newJoy","trigger","value","joystickName","substring","joystick","position","left","bottom","baseColor","stickColor","move","handleMove","stop","handleStop","start","handleStart","setState","prevState","ctx","clearRect","moveThing","constructor","addShape","newVals","element","fillStyle","addRect","CIRCLE","TRIANGLE","HEART","STAR","w","h","beginPath","rect","fill","comp","Component","StateNode","BTN_STATUS","RECURSIVE_MAX_DEPTH","sortRoots","roots","sort","b","groups","groupTracker","root","xVal","range","group","flat","Precompiler","precompile","mainSchema","ms","getRoots","sorte","index","arr","indexOf","precompRoot","depth","ifSchema","ifSchemaRoots","ifChildren","innerRoot","compChild","elseSchema","elseSchemaRoots","elseChildren","condition","getChildren","compiledCondition","leIf","whileSchema","whileSchemaRoots","compiledWhile","compNest","myChildren","compiledChildren","includes","portIds","childrenOutputPorts","link","input","output","portId","precompiledStuff","SchemaSerializor","save","ids","nodeIDStart","JSON","stringify","json","parse","valSchemas","emptyProgram","AppDiagram","setProgram","build","unflagNodes","compile","then","prog","catch","flagNodes","rtElem","run","runProg","serialize","deserialize","nID","loadSchemas","App","reportWebVitals","onPerfEntry","getCLS","getFID","getFCP","getLCP","getTTFB","StrictMode","ControlElement","displayName","MakeControlElementBlock","elem","ConsoleLogBlock","inp","EQBlock","leftSide","rightSide","GEQBlock","GTBlock","LEQBlock","LTBlock","ANDBlock","NOTBlock","bool","ORBlock","DivisionBlock","rVal","slice","num","ExponentBlock","firstNum","pow","Math","ModuloBlock","ProductBlock","operands","ans","op","SubtractBlock","SumBlock","stringMode","numVal","TernaryBlock","tValue","fValue","VarAssignBlock","evalValue","FORBlock","counterName","initialValue","incrementValue","len","incrValue","IFBlock","otherwise","ifLen","elseLen","max","andInpsConds","andBlock","cond","runBlocks","block","WHILEBlock","conditions","blocks","ConstBlock","ArrayCreateBlock","ArrayGetIndex","ArraySetIndex","VarDeleteBlock","delete","VarRetrieveBlock","c","d","DELETE","FOR"],"mappings":"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","file":"static/js/main.7ea9b396.chunk.js","sourcesContent":["import { TeaBlocksError } from './../../TeaBlocksError';\nimport { ReturnBlock } from \"../ReturnBlock\";\n\n/**\n * Takes in the shape name (display name), checks if the name exists, and returns the internal name of the shape.\n */\nexport class GetShapeBlock extends ReturnBlock {\n    shapeName: string;\n\n    /**\n     * Constructor\n     * @param shapeName the name of the shape being retrieved\n     */\n    constructor(id: string, shapeName: string) {\n        super(id)\n        this.shapeName = shapeName;\n    }\n\n    /**\n     * Retrieves the internal shape name. Throws error if it does not exist.\n     * @param varEnv variable environment\n     */\n    evalBlock(varEnv: Map<string, any>): string {\n        let internalName = '$' + this.shapeName;\n        if (varEnv.has(internalName)) return internalName;\n        throw new TeaBlocksError(`Shape ${this.shapeName} does not exist!`, this.id);\n    }\n\n}","import { TeaBlocksError } from './../../TeaBlocksError';\nimport { ShapeColor } from './ShapeColor';\nimport { ReturnBlock } from \"../ReturnBlock\";\nimport { VoidBlock } from \"../VoidBlock\";\nimport { Shape } from \"./Shape\";\nimport { ShapeType } from \"./ShapeType\";\n\n/**\n * Creates variable parameters for some shape\n */\nexport class MakeShapeBlock extends VoidBlock {\n    shapeName: ReturnBlock;\n    color: ShapeColor;\n    shapeType: ShapeType;\n    posX: ReturnBlock;\n    posY: ReturnBlock;\n    scaleX: ReturnBlock;\n    scaleY: ReturnBlock;\n    rot: ReturnBlock;\n\n    /**\n     * Constructor\n     * \n     * @param id the id\n     * @param shapeType the type of the shape\n     * @param color the color of the shape.\n     * @param inputs inputs\n     */\n    constructor(id:string, shapeType: ShapeType, color: ShapeColor,\n        inputs: ReturnBlock[]) {\n        super(id);\n        this.shapeType = shapeType;\n        this.color = color;\n\n        console.log(inputs);\n\n        this.shapeName = inputs[0];\n        this.posX = inputs[1];\n        this.posY = inputs[2];\n        this.scaleX = inputs[3];\n        this.scaleY = inputs[4];\n        this.rot = inputs[5];\n    }\n\n    /**\n     * Creates variable array for new shape\n     * @param varEnv variable environment\n     */\n    *evalBlock(varEnv: Map<string, any>) {\n        let shapeName = String(this.shapeName.evalBlock(varEnv));\n        let posx = Number(this.posX.evalBlock(varEnv));\n        let posy = Number(this.posY.evalBlock(varEnv));\n        let scalex = Number(this.scaleX.evalBlock(varEnv));\n        let scaley = Number(this.scaleY.evalBlock(varEnv));\n        let rot = Number(this.rot.evalBlock(varEnv));\n\n        console.log(shapeName);\n        console.log(posx);\n        console.log(posy);\n        console.log(scalex);\n        console.log(scaley);\n        console.log(rot);\n\n        if (isNaN(posx) ||\n            isNaN(posy) ||\n            isNaN(scalex) ||\n            isNaN(scaley) ||\n            isNaN(rot)) {\n            throw new TeaBlocksError(\"Shape input not a number\", this.id);\n        }\n\n        varEnv.set('$' + shapeName, new Shape(shapeName, this.shapeType, this.color, posx, posy, scalex, scaley, rot));\n        yield;\n    }\n}","\n/**\n * A class for a guranteed root node.\n */\nexport class GuranteedRoot{\n    isRoot: boolean;\n    constructor(){\n        this.isRoot = true;\n    }\n}","import { NodeData } from './NodeData';\nimport { BlockType } from './../compiler/factory/BlockType';\nimport { Node, NodeCoordinates, Port } from 'beautiful-react-diagrams/@types/DiagramSchema';\nimport { ElementType, ReactNode } from 'react';\nimport { CustomNode } from './CustomNode';\nimport DiagramIDE from '../ide/DiagramIDE';\n\n\nexport class InputNode implements CustomNode {\n    id: string;\n    coordinates: NodeCoordinates;\n    content: ReactNode;\n    outputs: Port[];\n    data: NodeData;\n    render: (\n        props: Omit<Node<any>, 'coordinates'>\n    ) => ElementType | ReactNode;\n    blockType: BlockType;\n    constInputs: any[];\n\n    /**\n     * \n     * @param content content of this node\n     * @param coordinates inital coordinates of the node\n     * @param numOutputs the number of output ports this node should have\n     * @param blockType the type of the assembly block created (for phasing out assConstructor)\n     * @param constInputs constant inputs that assembly block takes.\n     * @param data data of the node (any object; should contain assConstructor)\n     * @param render renderer used to render\n     * ! ^ data is kinda weird. need to figure out how to replace it with more concrete/safe types.\n     */\n    constructor(content: ReactNode,\n        coordinates: NodeCoordinates,\n        numOutputs: number,\n        blockType: BlockType,\n        constInputs: any[],\n        data: NodeData,\n        render: (props: Omit<Node<any>, 'coordinates'>) => ElementType | ReactNode) {\n        this.id = DiagramIDE.getID()\n        this.coordinates = coordinates;\n        this.content = content;\n        this.data = data;\n        this.render = render;\n\n        this.blockType = blockType;\n        this.constInputs = constInputs;\n\n        console.log('Inputs id: ' + this.id);\n\n        this.outputs = [];\n        for (let i = 0; i < numOutputs; i++) {\n            let port: Port = { id: this.id + '-output-' + i };\n            this.outputs.push(port);\n        }\n    }\n\n\n\n}","/**\n * Abstract assembly block class.\n */\nexport abstract class AbstractBlock{\n    id: string;\n\n    constructor(id: string){\n        this.id = id;\n    }\n\n\n    /**\n     * Function to evaluate the contents (including children) of this abstract block\n     * @param varEnv Variable Environment\n     */\n    abstract evalBlock(varEnv: Map<string, any>): any;\n}","export * from './ButtonStatusBlock';\nexport * from './JoyXStatusBlock';\nexport * from './JoyYStatusBlock';\nexport * from './AssemblyJoystick';\n","/**\n * An enum to specify the type of block being deserialized\n */\nexport enum BlockType{\n    CLB, // console log block\n    CONST,\n    EQ,\n    GEQ,\n    GT,\n    LEQ,\n    LT,\n    AND,\n    NOT,\n    OR,\n    DIV,\n    SUM,\n    SUBTRACT,\n    EXP,\n    MOD,\n    PROD,\n    MAKE_SHAPE,\n    MOVE_SHAPE,\n    ROTATE_SHAPE,\n    SCALE_SHAPE,\n    GET_SHAPE,\n    FOR,\n    IF,\n    WHILE,\n    TERNARY,\n    VAR_ASSIGN,\n    VAR_DELETE,\n    VAR_RETRIEVE,\n    NEST,\n    JOY_X,\n    JOY_Y,\n    BTN_STATUS,\n    ARR_CREATE,\n    ARR_SET_IX,\n    ARR_GET_IX,\n    MAKE_CONTROL_ELEM,\n    GET_X,\n    GET_Y,\n}","/**\n * A custom error for TeaBlocks runtime error that contain information about where (node)\n * the error originates from. These errors are created either by user error or\n * by bugs in the code :/\n */\nexport class TeaBlocksError extends Error {\n    id: string;\n\n    /**\n     * Constructor.\n     * @param message error message (kid friendly text)\n     * @param id the id of the assembly block/state node/diagram node that threw this error.\n     */\n    constructor(message: string, id: string) {\n        super(message);\n        this.id = id;\n        this.name = 'TeaBlocksError';\n    }\n}","import { AbstractBlock } from \"./AbstractBlock\";\n/**\n * An abstract class for assembly blocks that return \n */\nexport abstract class ReturnBlock extends AbstractBlock{\n    abstract evalBlock(varEnv: Map<string, any>): any;\n}","import { AbstractBlock } from \"./AbstractBlock\";\n\nexport abstract class VoidBlock extends AbstractBlock{\n    voidBlock: boolean = true;\n\n    abstract evalBlock(varEnv: Map<string,any>): IterableIterator<void>;\n\n    /**\n     * How many execution steps a void block takes to execute at most. The default value is 1.\n     * This method would be overriden by more complex void blocks such as loops and if statements\n     * that take more than one step to complete.\n     */\n    getLength(): number{\n        return 1;\n    }\n}","/**\n * The type of UI controll.\n */\nexport enum ControlType {\n    JOYSTICK='joy',\n    BUTTON='btn',\n}","import { NodeData } from './../codeBlocks/NodeData';\nimport { CustomNode } from './../codeBlocks/CustomNode';\nimport { DiagramSchema, Link } from \"beautiful-react-diagrams/@types/DiagramSchema\";\n\nconst FIRST_COORDINATE: [number, number] = [150, 60]; // coordinate of the first node\nconst NEXT_X: number = 150; // value to add to last x coordinate for the next node\n\nexport class CustomSchema implements DiagramSchema<NodeData>{\n    nodes: CustomNode[];\n    links: Link[];\n\n    constructor() {\n        this.nodes = [];\n        this.links = [];\n    }\n\n    /**\n     * Returns the coordinates for the next node. If no node exists it will return FIRST_COORIDNATE If a node\n     * exists, it will return NEXT_X more x value of the last node in schema. \n     */\n    getNextCoordinates(): [number, number] {\n        if (this.nodes == null || this.nodes.length === 0) {\n            return FIRST_COORDINATE;\n        }\n        return [\n            this.nodes[this.nodes.length - 1].coordinates[0] + NEXT_X,\n            this.nodes[this.nodes.length - 1].coordinates[1]\n        ]\n    }\n\n    \n\n}","import { ControlType } from './../compiler/assemblyBlocks/inputBlocks/ControlType';\nimport { BlockType } from '../compiler/factory';\nimport { CustomRender, IfRender, WhileRender } from '../diagram/renders';\nimport { ShapeType, ShapeColor } from '../compiler/assemblyBlocks/shape';\nimport { FunctionNode, OutputNode, InputNode, IfNode, WhileNode } from '../codeBlocks';\nimport DiagramIDE from './DiagramIDE';\n\n/**\n * A class that adds nodes to the schema. (For cleanness)\n */\nexport class NodeBuilder {\n    parentSchemaId;\n\n    /**\n     * Constructor\n     * @param addNode function to add node to schema.\n     * @param schemaId the id of the parent schema.\n     */\n    constructor(schemaId: string) {\n        this.parentSchemaId = schemaId\n    }\n\n    private centralizeCoordinates(coordinates: [number, number]): [number, number] {\n        return [coordinates[0] - 100, coordinates[1] - 100];\n    }\n\n    private nextCoordinates(): [number, number] {\n        if (!DiagramIDE.getIDE().validatedSchemas.has(this.parentSchemaId)) throw Error('Not initalized!');\n        let coors = DiagramIDE.getIDE().validatedSchemas.get(this.parentSchemaId)?.getNextCoordinates();\n        return coors ? coors : [0, 0];\n    }\n\n    /**\n     * Creates a block with this block into the diagram.\n     * @param type type of block created\n     * @param coordinates the coordinates where to make\n     */\n    makeFunction(type: BlockType, coordinates: [number, number] = this.nextCoordinates()) {\n        coordinates = this.centralizeCoordinates(coordinates);\n\n        switch (type) {\n            case BlockType.SUM:\n                this.addFunctionNode('Adder', type, [], 2, 1, ['In', 'In'], ['Out'], coordinates);\n                break;\n            case BlockType.PROD:\n                this.addFunctionNode('Multiply', type, [], 2, 1, ['In', 'In'], ['Out'], coordinates);\n                break;\n            case BlockType.SUBTRACT:\n                this.addFunctionNode('Subtract', type, [], 2, 1, ['In', 'In'], ['Out'], coordinates);\n                break;\n            case BlockType.DIV:\n                this.addFunctionNode('Divide', type, [], 2, 1, ['In', 'In'], ['Out'], coordinates);\n                break;\n            case BlockType.EQ:\n                this.addFunctionNode('==', type, [], 2, 1, ['Left', 'Right'], ['Out'], coordinates);\n                break;\n            case BlockType.LT:\n                this.addFunctionNode('<', type, [], 2, 1, ['Left', 'Right'], ['Out'], coordinates);\n                break;\n            case BlockType.GT:\n                this.addFunctionNode('>', type, [], 2, 1, ['Left', 'Right'], ['Out'], coordinates);\n                break;\n            case BlockType.LEQ:\n                this.addFunctionNode('<=', type, [], 2, 1, ['Left', 'Right'], ['Out'], coordinates);\n                break;\n            case BlockType.GEQ:\n                this.addFunctionNode('>=', type, [], 2, 1, ['Left', 'Right'], ['Out'], coordinates);\n                break;\n            case BlockType.AND:\n                this.addFunctionNode('AND', type, [], 2, 1, ['Left', 'Right'], ['Out'], coordinates);\n                break;\n            case BlockType.OR:\n                this.addFunctionNode('OR', type, [], 2, 1, ['Left', 'Right'], ['Out'], coordinates);\n                break;\n            case BlockType.NOT:\n                this.addFunctionNode('NOT', type, [], 1, 1, ['in'], ['Out'], coordinates);\n                break;\n            case BlockType.TERNARY:\n                this.addFunctionNode('Ternary', type, [], 3, 1, ['If', 'Then', 'Else'], ['Out'], coordinates);\n                break;\n            case BlockType.MOD:\n                this.addFunctionNode('Modulo %', type, [], 2, 1, ['In', 'In'], ['Out'], coordinates);\n                break;\n            case BlockType.EXP:\n                this.addFunctionNode('Exponent', type, [], 2, 1, ['In', 'In'], ['Out'], coordinates);\n                break;\n            case BlockType.GET_X:\n                this.addFunctionNode('Get X', type, [], 1, 1, ['Shape'], ['X'], coordinates);\n                break;\n            case BlockType.GET_Y:\n                this.addFunctionNode('Get Y', type, [], 1, 1, ['Shape'], ['Y'], coordinates);\n                break;\n            default:\n                console.error('This type is not supported by makeFunction')\n        }\n\n    }\n\n    /**\n     * Creates a block with this block type.\n     * @param {BlockType} type type of block created\n     * @param coordinates the coordinates where to make\n     */\n    makeInput(type: BlockType, coordinates: [number, number] = this.nextCoordinates()) {\n        coordinates = this.centralizeCoordinates(coordinates);\n\n        switch (type) {\n            case BlockType.CONST:\n                let cstVal = prompt('What is the value?', '0');\n                this.addInputNode(`Constant: ${cstVal}`, type, [cstVal], 1, ['Value'], coordinates);\n                break;\n            case BlockType.VAR_RETRIEVE:\n                let varName = prompt('What is the name of the variable?');\n                this.addInputNode(`Get ${varName}`, type, [varName], 1, ['Value'], coordinates);\n                break;\n            case BlockType.GET_SHAPE:\n                let shapeget = prompt('What shape name?');\n                this.addInputNode(`Get ${shapeget}`, type, [shapeget], 1, ['Shape'], coordinates);\n                break;\n            case BlockType.JOY_X:\n                let joyxname = prompt('What joystick name?', 'joystick');\n                this.addInputNode(`Get ${joyxname} X`, type, [joyxname], 1, ['X'], coordinates);\n                break;\n            case BlockType.JOY_Y:\n                let joyyname = prompt('What joystick name?', 'joystick');\n                this.addInputNode(`Get ${joyyname} Y`, type, [joyyname], 1, ['Y'], coordinates);\n                break;\n            case BlockType.ARR_GET_IX:\n                let arrName = prompt('What is the array name');\n                this.addInputNode(`Get ${arrName}`, type, [arrName], 1, ['Value'], coordinates);\n                break;\n            default:\n                console.error('This type is not supported by makeInput')\n                return;\n        }\n    }\n\n    /**\n     * Creates an output block.\n     * @param {BlockType} type type of block\n     * @param coordinates the coordinates\n     */\n    makeOutput(type: BlockType, coordinates: [number, number] = this.nextCoordinates()) {\n        coordinates = this.centralizeCoordinates(coordinates);\n\n        switch (type) {\n            case BlockType.CLB:\n                this.addOutputNode('Console', type, [], 1, ['Value'], coordinates);\n                break;\n            case BlockType.VAR_ASSIGN:\n                let varName = prompt('Pick a variable name');\n                this.addOutputNode(`Assign ${varName}`, type, [varName], 1, ['Value'], coordinates);\n                break;\n            case BlockType.VAR_DELETE:\n                let varDeleteName = prompt('Pick a variable name to delete');\n                this.addOutputNode(`Delete ${varDeleteName}`, type, [varDeleteName], 0, [], coordinates);\n                break;\n            case BlockType.MAKE_SHAPE:\n                let shapeType = prompt('Pick a type!', ShapeType.RECT);\n                let color = prompt('Pick a color (rgb value)', ShapeColor.BLUE);\n                this.addOutputNode(`Make ${shapeType}`, type, [shapeType, color], 6, ['Name', 'X', 'Y', 'Stretch-X', 'Stretch-Y', 'Rotation'], coordinates);\n                break;\n            case BlockType.ROTATE_SHAPE:\n                this.addOutputNode('Rotate', type, [], 2, ['Shape', 'Rotation'], coordinates);\n                break;\n            case BlockType.MOVE_SHAPE:\n                this.addOutputNode('Move', type, [], 3, ['Shape', 'X', 'Y'], coordinates);\n                break;\n            case BlockType.SCALE_SHAPE:\n                this.addOutputNode('Stretch', type, [], 3, ['Shape', 'X', 'Y'], coordinates);\n                break;\n            case BlockType.ARR_CREATE:\n                let arrMake = prompt('What is the name of array?');\n                this.addOutputNode(`Create ${arrMake}`, type, [arrMake], 0, [], coordinates);\n                break;\n            case BlockType.ARR_SET_IX:\n                let arrName = prompt('What is the name of array?');\n                this.addOutputNode(`Set ${arrName}`, type, [arrName], 2, ['Index', 'Value'], coordinates);\n                break;\n            case BlockType.MAKE_CONTROL_ELEM:\n                let elemType = prompt('Pick element type', ControlType.JOYSTICK);\n                let elemName = prompt('Pick element name', 'joystick');\n                this.addOutputNode(`Make ${elemName}`, type, [elemType, elemName], 2, ['X', 'Y'], coordinates);\n                break;\n            default:\n                console.error('This node is not supported by makeOutput');\n                return;\n        }\n    }\n\n    makeSpecial(type: BlockType, coordinates: [number, number] = this.nextCoordinates()) {\n        coordinates = this.centralizeCoordinates(coordinates);\n\n        switch (type) {\n            case BlockType.IF:\n                const nextIf = new IfNode('IF',\n                    coordinates,\n                    [],\n                    {\n                        parentSchema: this.parentSchemaId,\n                        inputNames: ['Condition'],\n                        problematic: false,\n                    },\n                    IfRender);\n\n                DiagramIDE.getIDE().schemaMethods.get(this.parentSchemaId)?.addNode(nextIf);\n\n                break;\n            case BlockType.WHILE:\n                const nextWhile = new WhileNode('WHILE',\n                    coordinates,\n                    [],\n                    {\n                        parentSchema: this.parentSchemaId,\n                        inputNames: ['Condition'],\n                        problematic: false,\n                    },\n                    WhileRender);\n                DiagramIDE.getIDE().schemaMethods.get(this.parentSchemaId)?.addNode(nextWhile);\n                break\n            default:\n                console.error('This node is not supported by makeSpecial')\n                return;\n        }\n    }\n\n    /**\n     * Adds an input node.\n     * @param {string} name name of the node\n     * @param {BlockType} type type of block\n     * @param {any[]} constVal constant values\n     * @param {number} numOfOutputs the number of outputs of this nod\n     * @param {string[]} outputNames the names of each output of this node\n     * @param coordinates the coordinates of this node. \n     */\n    addInputNode(name: {} | null | undefined, type: BlockType, constVal: any[], numOfOutputs: number, outputNames: string[] = [], coordinates: [number, number]) {\n        const nextNode = new InputNode(name,\n            coordinates,\n            numOfOutputs,\n            type,\n            constVal,\n            { parentSchema: this.parentSchemaId, outputNames: outputNames, problematic: false },\n            CustomRender);\n\n        DiagramIDE.getIDE().schemaMethods.get(this.parentSchemaId)?.addNode(nextNode);\n    }\n\n    /**\n     * Makes an output node\n     * @param {string} name name\n     * @param {BlockType} type type of block this is\n     * @param {any[]} constVal constant values\n     * @param {number} numOfInputs number of inputs\n     * @param {string[]} inputNames the names of each input to this node\n     * @param coordinates the coordinates of the node\n     */\n    addOutputNode(name: string, type: BlockType, constVal: any[], numOfInputs: number, inputNames: string[], coordinates: [number, number]) {\n        const nextNode = new OutputNode(name,\n            coordinates,\n            numOfInputs,\n            type,\n            constVal,\n            { parentSchema: this.parentSchemaId, inputNames: inputNames, problematic: false },\n            CustomRender);\n\n        DiagramIDE.getIDE().schemaMethods.get(this.parentSchemaId)?.addNode(nextNode);\n\n    }\n\n    /**\n     * Makes a function node\n     * @param {string} name name of the node\n     * @param {BlockType} type type of block\n     * @param {any[]} constVal constant values\n     * @param {number} numOfInputs number of inputs\n     * @param {number} numOfOutputs number of outputs\n     * @param {string[]} inputNames the names of each input to this node\n     * @param {string[]} outputNames the names of each output of this node\n     */\n    addFunctionNode(name: string, type: BlockType, constVal: any[], numOfInputs: number, numOfOutputs: number, inputNames: string[], outputNames: string[], coordinates: [number, number]) {\n        const nextNode = new FunctionNode(name,\n            coordinates,\n            numOfInputs,\n            numOfOutputs,\n            type,\n            constVal,\n            { parentSchema: this.parentSchemaId, inputNames: inputNames, outputNames: outputNames, problematic: false },\n            CustomRender);\n\n        DiagramIDE.getIDE().schemaMethods.get(this.parentSchemaId)?.addNode(nextNode);\n    }\n\n\n\n}","import Diagram from \"beautiful-react-diagrams\";\nimport '../styles/UncontrolledDiagram.scss';\n\n\n/**\n * A shitty wrapper for a shitty library.\n * @param {any} props the props if u know what i mean :/ \n * @return {JSX.Element}\n */\nexport default function DiagramWrapper(props) {\n    return (\n        <Diagram schema={props.schema} onChange={props.onChange} />\n    );\n}","import '../styles/UncontrolledDiagram.scss';\nimport { useSchema } from 'beautiful-react-diagrams';\nimport { useEffect, useState } from 'react';\nimport { Button } from 'beautiful-react-ui';\nimport { CustomSchema } from './CustomSchema';\nimport { NodeBuilder } from '../ide/NodeBuilder';\nimport { BlockType } from '../compiler/factory';\nimport DiagramIDE from '../ide/DiagramIDE';\nimport DiagramWrapper from './DiagramWrapper';\n\ninterface Props {\n    schemaId: string;\n}\n\nexport default function UncontrolledDiagram(props: Props) {\n\n    let initialSchema = DiagramIDE.getIDE().validatedSchemas.get(props.schemaId);\n\n    const [schema, { onChange, addNode, removeNode }] = useSchema(initialSchema ? initialSchema : new CustomSchema());\n\n    const deleteNodeFromSchema = (id: string) => {\n        const nodeToRemove = schema.nodes.find(node => node.id === id);\n\n        if (nodeToRemove) {\n            removeNode(nodeToRemove);\n        }\n    };\n\n    const [nodeBuilder] = useState(new NodeBuilder(props.schemaId));\n    const [makeCallback, setMakeCallback] = useState(Function);\n\n\n    useEffect(() => {\n        DiagramIDE.getIDE().addSchema(props.schemaId, schema as CustomSchema, {\n            deleteNodeFromSchema: deleteNodeFromSchema,\n            onChange: onChange,\n            addNode: addNode\n        });\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [schema]);\n\n\n    function clickMakeNode(e: React.MouseEvent): void {\n        if (makeCallback == null) {\n            return;\n        }\n\n        makeCallback([e.pageX, e.pageY]);\n        setMakeCallback(() => { });\n    }\n\n    function scheduleMakeInput(type: BlockType) {\n        const callback = (coor: [number, number]) => {\n            nodeBuilder.makeInput(type, coor);\n        }\n        setMakeCallback(() => callback);\n    }\n\n    function scheduleMakeOutput(type: BlockType) {\n        const callback = (coor: [number, number]) => {\n            nodeBuilder.makeOutput(type, coor);\n        }\n        setMakeCallback(() => callback);\n    }\n\n    function scheduleMakeFunction(type: BlockType) {\n        const callback = (coor: [number, number]) => {\n            nodeBuilder.makeFunction(type, coor);\n        }\n        setMakeCallback(() => callback);\n    }\n\n    function scheduleMakeSpecial(type: BlockType) {\n        const callback = (coor: [number, number]) => {\n            nodeBuilder.makeSpecial(type, coor);\n        }\n        setMakeCallback(() => callback);\n    }\n\n\n    return (\n        <div className=\"diagram-section\" >\n            <div className=\"diagram-display-area\" onClick={e => clickMakeNode(e)}>\n                <DiagramWrapper schema={schema} onChange={onChange} />\n            </div>\n            <div className={'sidebar'}>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeInput(BlockType.CONST)}>Constant</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeOutput(BlockType.VAR_ASSIGN)}>Variable Assign</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeInput(BlockType.VAR_RETRIEVE)}>Variable Get</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeOutput(BlockType.VAR_DELETE)}>Variable Delete</Button>\n                <hr />\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeOutput(BlockType.ARR_CREATE)}>Create Array</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeOutput(BlockType.ARR_SET_IX)}>Array Set Index</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeInput(BlockType.ARR_GET_IX)}>Array Get Index</Button>\n                <hr />\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.SUM)}>Adder</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.SUBTRACT)}>Subtract</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.PROD)}>Multiply</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.DIV)}>Divide</Button>\n                <hr />\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeOutput(BlockType.MAKE_CONTROL_ELEM)}>Create Control</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeInput(BlockType.JOY_X)}>Joystick X</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeInput(BlockType.JOY_Y)}>Joystick Y</Button>\n                <hr />\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeOutput(BlockType.MAKE_SHAPE)}>Shape</Button>\n                <Button color=\"primary\" icon=\"arrow-up\" onClick={() => scheduleMakeInput(BlockType.GET_SHAPE)}>Get Shape</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeOutput(BlockType.MOVE_SHAPE)}>Move Shape</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeOutput(BlockType.ROTATE_SHAPE)}>Rotate Shape</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeOutput(BlockType.SCALE_SHAPE)}>Stretch Shape</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.GET_X)}>Get X</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.GET_Y)}>Get Y</Button>\n\n                <hr />\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.GEQ)}>&gt;=</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.LEQ)}>&lt;=</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.LT)}>&lt;</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.GT)}>&gt;</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.EQ)}>==</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.AND)}>AND</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.OR)}>OR</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.NOT)}>NOT</Button>\n                <hr />\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.TERNARY)}>if then else</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeSpecial(BlockType.IF)}>IF</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeSpecial(BlockType.WHILE)}>WHILE</Button>\n\n\n                <hr />\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeOutput(BlockType.CLB)}>Print</Button>\n            </div>\n        </div>\n    );\n};","import ReactDOM from 'react-dom';\nimport { CustomSchema } from '../diagram/CustomSchema';\nimport UncontrolledDiagram from '../diagram/UncontrolledDiagram';\n\nconst IDE_ID = 'ide';\n\n/**\n * An interface for a bundle of schema operations.\n */\ninterface SchemaMethodBundle {\n    deleteNodeFromSchema: Function;\n    onChange: Function;\n    addNode: Function;\n}\n\n/**\n * Manually renderes diagram component using ReactDOM. This is a singleton class;\n * use getIDE method to get the instance of the ide.\n */\nexport default class DiagramIDE {\n    ideId: string;\n    validatedSchemas: Map<string, CustomSchema>;\n    schemaMethods: Map<string, SchemaMethodBundle>;\n\n    displaySchemaId: string;\n\n    private static globalNextId = 0;\n\n    public static getID(): string {\n        return String(DiagramIDE.globalNextId++);\n    }\n\n\n    private static instance: DiagramIDE;\n\n\n    /**\n     * Private constructor\n     * @param ideId the ID of the DOM element where the IDE diagram should be rendered\n     */\n    private constructor(ideId: string) {\n        this.validatedSchemas = new Map();\n        this.schemaMethods = new Map();\n        this.displaySchemaId = 'main';\n        this.ideId = ideId;\n    }\n\n    public static getIDE() {\n        if (!DiagramIDE.instance) {\n            DiagramIDE.instance = new DiagramIDE(IDE_ID);\n        }\n\n        return DiagramIDE.instance;\n    }\n\n    /**\n     * Renders diagram RFC in the DOM element with the ideId as the id.\n     * This method is only called when a fresh diagram is needed; it is\n     * not called when an existing diagram needs updating.\n     */\n    public renderDiagram() {\n        console.log('rendering IDE');\n\n        let toRender = (<div>\n            <UncontrolledDiagram schemaId={this.displaySchemaId} />\n        </div>);\n\n        ReactDOM.render(toRender, document.getElementById(this.ideId));\n    }\n\n    /**\n     * Unmounts the current diagram and calls renderDiagram.\n     */\n    public redrawDiagram() {\n        let leRoot = document.getElementById(this.ideId);\n        if (leRoot) {\n            ReactDOM.unmountComponentAtNode(leRoot);\n        }\n        this.renderDiagram();\n    }\n\n    /**\n     * Add a VALIDATED schema to the diagram before a diagram is unmounted.\n     * @param schemaId id of schema being added\n     * @param schema schema being added\n     * @param methods a bundle of schema methods\n     */\n    public addSchema(schemaId: string, schema: CustomSchema, methods: SchemaMethodBundle): void {\n        this.validatedSchemas.set(schemaId, schema);\n        this.schemaMethods.set(schemaId, methods)\n    }\n\n    /**\n     * Setter for displaySchemaId. Should be used to change to an EXISTING\n     * schema. Calls redrawDiagram to update DOM.\n     * @param schemaId id of new schema being displayed.\n     */\n    public setDisplaySchemaId(schemaId: string): void {\n        this.displaySchemaId = schemaId;\n        this.redrawDiagram();\n    }\n\n    /**\n     * Loads validated schemas from save; calls to rerender.\n     * @param schemas validated schemas from the save\n     * @param startID the new value for the node id counter\n     */\n    public loadSchemas(schemas: Map<string, CustomSchema>, startID: string): void {\n        this.validatedSchemas = schemas;\n        DiagramIDE.globalNextId = Number(startID);\n        this.schemaMethods = new Map(); // old methods no longer valid\n\n        this.displaySchemaId = 'main';\n        this.redrawDiagram();\n    }\n\n    /**\n     * Searches through schema to find nodes with nodeId and flag them as problematic.\n     * This is done when a node throws a TeaBlocksError.\n     * \n     * @param nodeId the id's of nodes that are to be flagged as problematic.\n     */\n    public flagNodes(...nodeId: string[]): void {\n        nodeId.forEach(id => {\n            for (let schema of Array.from(this.validatedSchemas.values())) {\n                let foundNode = schema.nodes.find(node => node.id === id);\n                if (foundNode) {\n                    foundNode.data.problematic = true;\n                    console.log(`Flagged ${id}!`);\n                    break;\n                }\n            }\n        })\n    }\n\n    /**\n     * Goes through each node in each schema and sets the problematic flag to\n     * false.\n     */\n    public unflagNodes(): void {\n        this.validatedSchemas.forEach(schema => {\n            schema.nodes.forEach(node => node.data.problematic = false);\n        })\n    }\n}\n","import { ReturnBlock } from \"../ReturnBlock\";\n\n/**\n * A boolean return block that gets if the button is pressed or not\n */\nexport class ButtonStatusBlock extends ReturnBlock {\n    buttonName: string;\n\n    /**\n     * Constructor\n     * @param id the id.\n     * @param buttonName the unique name of this button (what the user sees)\n     */\n    constructor(id: string, buttonName: string) {\n        super(id);\n        this.buttonName = buttonName;\n    }\n\n    /**\n     * Gets the value of '$btn-buttonName' from variable environment.\n     * @param varEnv variable environment\n     * @returns the boolean value of the button status (false if it does not exist);\n     */\n    evalBlock(varEnv: Map<string, any>) {\n        let val = varEnv.get('&btn-' + this.buttonName); //! come back to this\n        return Boolean(val);\n    }\n\n}","import { TeaBlocksError } from './../../TeaBlocksError';\nimport { AssemblyJoystick } from './AssemblyJoystick';\nimport { ReturnBlock } from \"../ReturnBlock\";\n\n/**\n * Gets the x value from a joystick with a specific name. Does not create the joystick.\n */\nexport class JoyXStatusBlock extends ReturnBlock {\n    joyName: string;\n\n    constructor(id: string, joyName: string) {\n        super(id)\n        this.joyName = joyName;\n    }\n\n    /**\n     * Returns the x value of joystick. I.e. the x value of '&joyName'\n     * @param varEnv variable environment\n     */\n    evalBlock(varEnv: Map<string, any>) {\n        let vName = '&' + this.joyName;\n\n        if (!varEnv.has(vName)) throw new TeaBlocksError(`Joystick ${this.joyName} does not exist`, this.id);\n\n        let joy: AssemblyJoystick = varEnv.get(vName);\n\n        return joy.x;\n    }\n}","import { TeaBlocksError } from './../../TeaBlocksError';\nimport { AssemblyJoystick } from './AssemblyJoystick';\nimport { ReturnBlock } from \"../ReturnBlock\";\n\n/**\n * Gets the y value from a joystick with a specific name. Does not create the joystick.\n */\nexport class JoyYStatusBlock extends ReturnBlock {\n    joyName: string;\n\n    constructor(id: string, joyName: string) {\n        super(id)\n        this.joyName = joyName;\n    }\n\n    /**\n     * Returns the y value of joystick. I.e. the y value of '&joyName'\n     * @param varEnv variable environment\n     */\n    evalBlock(varEnv: Map<string, any>) {\n        let vName = '&' + this.joyName;\n\n        if (!varEnv.has(vName)) throw new TeaBlocksError(`Joystick ${this.joyName} does not exist`, this.id);\n\n        let joy: AssemblyJoystick = varEnv.get(vName);\n\n        return joy.y;\n    }\n}","import { Button } from 'beautiful-react-ui';\nimport '../../styles/CustomRender.scss';\nimport { RenderProps } from './RenderProps';\nimport { RenderHelper } from './RenderHelper';\n\nexport function CustomRender(props: RenderProps) {\n    \n    let inpDivs = props.inputs ? RenderHelper.makeInputDivs(props.inputs, props.data.inputNames) : [];\n    let outDivs = props.outputs ? RenderHelper.makeOutputDivs(props.outputs, props.data.outputNames) : [];\n \n    return (\n        <div className={\"node-wrapper\"}>\n            <div className={props.data.problematic ? \"custom-node-problem\" : \"custom-node\"} >\n                <div className=\"deleteBtn\">\n                    <Button icon=\"times\" size=\"small\" onClick={() => RenderHelper.deleteNode(props.data.parentSchema, props.id)} />\n                </div>\n                <div className=\"ports\">\n                    <div className=\"inputs\">\n                        {inpDivs}\n                    </div>\n                    <div className=\"content\">\n                        {props.content}\n                    </div>\n                    <div className=\"outputs\">\n                        {outDivs}\n                    </div>\n                </div>\n            </div>\n        </div>\n    )\n}\n\n","import React from 'react'\nimport { Button } from 'beautiful-react-ui';\nimport '../../styles/SpecialRender.scss';\nimport DiagramIDE from '../../ide/DiagramIDE';\nimport { RenderProps } from './RenderProps';\nimport { RenderHelper } from './RenderHelper';\n\nexport function IfRender(props: RenderProps) {\n    let inpDivs = props.inputs ? RenderHelper.makeInputDivs(props.inputs, props.data.inputNames) : [];\n\n    function trueButton() {\n        console.log(\"Clicked True button! (going to if schema)\");\n        DiagramIDE.getIDE().setDisplaySchemaId(`${props.id}if`);\n    }\n\n    function falseButton() {\n        console.log(\"Clicked False button! (going to else schema)\");\n        DiagramIDE.getIDE().setDisplaySchemaId(`${props.id}else`);\n    }\n\n    return (\n        <div>\n            <div className=\"if-node\" >\n                <div className=\"deleteBtn\">\n                    <Button icon=\"times\" size=\"small\" onClick={() => RenderHelper.deleteNode(props.data.parentSchema, props.id)} />\n                </div>\n\n                <div className=\"ports\">\n                    <div className=\"inputs\">\n                        {inpDivs}\n                    </div>\n                    <div className=\"content\">\n                        {props.content}\n                    </div>\n                </div>\n                <div className=\"buttons\">\n                    <button className=\"true-btn\" onClick={trueButton}>True</button>\n                    <button className=\"false-btn\" onClick={falseButton}>False</button>\n                </div>\n            </div>\n        </div>\n    )\n}\n\n","import { Button } from 'beautiful-react-ui';\nimport '../../styles/SpecialRender.scss';\nimport DiagramIDE from '../../ide/DiagramIDE';\nimport { RenderProps } from './RenderProps';\nimport { RenderHelper } from './RenderHelper';\n\nexport function WhileRender(props: RenderProps) {\n    let inpDivs = props.inputs ? RenderHelper.makeInputDivs(props.inputs, props.data.inputNames) : [];\n\n    function loopButton() {\n        console.log(\"Clicked loop button!\");\n        DiagramIDE.getIDE().setDisplaySchemaId(`${props.id}while`);\n    }\n\n    return (\n        <div>\n            <div className=\"while-node\">\n                <div className=\"deleteBtn\">\n                    <Button icon=\"times\" size=\"small\" onClick={() => RenderHelper.deleteNode(props.data.parentSchema, props.id)} />\n                </div>\n                <div className=\"ports\">\n                    <div className=\"inputs\">\n                        {inpDivs}\n                    </div>\n                    <div className=\"content\">\n                        {props.content}\n                    </div>\n                </div>\n                <div className=\"buttons\">\n                    <button className=\"loop-btn\" onClick={loopButton}>Loop</button>\n                </div>\n            </div>\n        </div>\n    )\n}\n\n","import { NodeData } from './NodeData';\nimport { BlockType } from './../compiler/factory/BlockType';\nimport { Node, NodeCoordinates, Port } from 'beautiful-react-diagrams/@types/DiagramSchema';\nimport { ElementType, ReactNode } from 'react';\nimport { CustomNode } from './CustomNode';\nimport DiagramIDE from '../ide/DiagramIDE';\n\n\nexport class FunctionNode implements CustomNode {\n    id: string;\n    coordinates: NodeCoordinates;\n    content: ReactNode;\n    inputs: Port[];\n    outputs: Port[];\n    data: NodeData;\n    render: (props: Omit<Node<any>, 'coordinates'>) => ElementType | ReactNode;\n\n    blockType: BlockType;\n    constInputs: any[];\n\n    /**\n     * \n     * @param content content of this node\n     * @param coordinates inital coordinates of the node\n     * @param numInputs the number of input ports this node should have\n     * @param numOutputs the number of output ports this node should have\n     * @param blockType the type of the assembly block created (for phasing out assConstructor)\n     * @param constInputs constant inputs that assembly block takes.\n     * @param data data of the node (any object; should contain assConstructor)\n     * @param render renderer used to render\n     * ! ^ data is kinda weird. need to figure out how to replace it with more concrete/safe types.\n     */\n    constructor(content: ReactNode,\n        coordinates: NodeCoordinates,\n        numInputs: number,\n        numOutputs: number,\n        blockType: BlockType,\n        constInputs: any[],\n        data: NodeData,\n        render: (props: Omit<Node<any>, 'coordinates'>) => ElementType | ReactNode) {\n\n        this.id = DiagramIDE.getID()\n        this.coordinates = coordinates;\n        this.content = content;\n        this.data = data;\n        this.render = render;\n\n        this.blockType = blockType;\n        this.constInputs = constInputs;\n\n        this.outputs = [];\n        for (let i = 0; i < numOutputs; i++) {\n            let port: Port = { id: this.id + '-output-' + i };\n            this.outputs.push(port);\n        }\n\n        this.inputs = [];\n        for (let i = 0; i < numInputs; i++) {\n            let port: Port = { id: this.id + '-input-' + i };\n            this.inputs.push(port);\n        }\n    }\n\n\n\n}","import { NodeData } from './NodeData';\nimport { BlockType } from './../compiler/factory/BlockType';\nimport { Node } from 'beautiful-react-diagrams/@types/DiagramSchema';\nimport { NodeCoordinates } from 'beautiful-react-diagrams/@types/DiagramSchema';\nimport { ElementType, ReactNode } from 'react';\nimport { OutputNode } from './OutputNode';\n\n/**\n * A code block IfNode\n */\nexport class IfNode extends OutputNode {\n    constructor(content: ReactNode,\n        coordinates: NodeCoordinates,\n        constInputs: any[],\n        data: NodeData,\n        render: (props: Omit<Node<any>, 'coordinates'>) => ElementType | ReactNode) {\n        //todo replace with custom renderer\n        super(content, coordinates, 1, BlockType.IF, constInputs, data, render);\n    }\n}","import { NodeData } from './NodeData';\nimport { BlockType } from './../compiler/factory/BlockType';\nimport { Node } from 'beautiful-react-diagrams/@types/DiagramSchema';\nimport { NodeCoordinates } from 'beautiful-react-diagrams/@types/DiagramSchema';\nimport { ElementType, ReactNode } from 'react';\nimport { OutputNode } from './OutputNode';\n\n/**\n * A code block WhileNode\n */\nexport class WhileNode extends OutputNode {\n    constructor(content: ReactNode,\n        coordinates: NodeCoordinates,\n        constInputs: any[],\n        data: NodeData,\n        render: (props: Omit<Node<any>, 'coordinates'>) => ElementType | ReactNode) {\n        //todo replace with custom renderer\n        super(content, coordinates, 1, BlockType.WHILE, constInputs, data, render);\n    }\n}","import '../../styles/CustomRender.scss';\nimport React from 'react';\nimport DiagramIDE from '../../ide/DiagramIDE';\n\n/**\n * A JavaScript class to do the type-ambiguous dirtywork for TypeScript Renderers.\n * If things go wrong it's all in this class.\n */\nexport class RenderHelper {\n    /**\n     * Makes the React elements for the input ports.\n     * @param inputs the input ports\n     * @param inputNames the list of names of input ports\n     * @returns {ReactNode[]}\n     */\n    static makeInputDivs(inputs, inputNames) {\n        let inpDivs = [];\n        if (inputs) {\n            for (let ix = 0; ix < inputs.length; ix++) {\n                inpDivs.push((\n                    <div className='InputPortDiv' key={inputs[ix].key + 'div'}>\n                        {React.cloneElement(inputs[ix], { className: \"port\" })}\n                        {inputNames && <label>{inputNames[ix]}</label>}\n                    </div>\n                ));\n            }\n        }\n\n        return inpDivs;\n    }\n\n    /**\n     * Makes the React elements for the output ports.\n     * @param outputs the output ports\n     * @param outputNames the list of names of output ports\n     * @returns {ReactNode[]}\n     */\n    static makeOutputDivs(outputs, outputNames) {\n        let outDivs = [];\n        if (outputs) {\n            for (let ix = 0; ix < outputs.length; ix++) {\n                outDivs.push((\n                    <div className='OutputPortDiv' key={outputs[ix].key + 'div'}>\n                        {outputNames && <label>{outputNames[ix]}</label>}\n                        {React.cloneElement(outputs[ix], { className: \"port\" })}\n\n                    </div>\n                ));\n            }\n        }\n\n        return outDivs;\n    }\n\n    static deleteNode(parentSchema, id) {\n        DiagramIDE.getIDE()\n            .schemaMethods\n            .get(parentSchema)\n            .deleteNodeFromSchema(id);\n    }\n}","export * from './CustomRender';\nexport * from './IfRender';\nexport * from './RenderProps';\nexport * from './WhileRender';\nexport * from './RenderHelper';\n\n","/**\n * A custom error for when something goes wrong with the internals of the compiler.\n * Serious software gore territory.\n */\nexport class InternalCompilerError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'InternalCompilerError';\n\n    }\n}","export enum ShapeColor {\n    BLACK = 'rgb(0,0,0)',\n    WHITE = 'rgb(255,255,255)',\n    GREY = 'rgb(155,155,155)',\n    RED = 'rgb(255,0,0)',\n    GREEN = 'rgb(0,255,0)',\n    BLUE = 'rgb(0,0,255)',\n    YELLOW = 'rgb(255,255,0)',\n    PURPLE = 'rgb(128,0,128)',\n    BROWN = 'rgb(110,60,34)',\n    ORANGE = 'rgb(255,89,0)',\n    PINK = 'rgb(255,0,255)',\n}","import { Shape } from './Shape';\nimport { TeaBlocksError } from './../../TeaBlocksError';\nimport { ReturnBlock } from \"../ReturnBlock\";\n\n/**\n * Gets the x position of a shape\n */\nexport class GetXBlock extends ReturnBlock {\n    shape: ReturnBlock\n\n    /**\n     * Constructor\n     * @param id the id\n     * @param inputs inputs[0] is the get shape.\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id);\n        this.shape = inputs[0];\n    }\n\n    /**\n     * Returns x position.\n     * @param varEnv variable environment\n     */\n    evalBlock(varEnv: Map<string, any>){\n        let shapeName = this.shape.evalBlock(varEnv);\n\n        let shape: Shape = varEnv.get(shapeName);\n        \n        if(!shape) throw new TeaBlocksError('This shape does not exist', this.id);\n\n        return shape.posX;\n    }\n}","import { Shape } from './Shape';\nimport { TeaBlocksError } from './../../TeaBlocksError';\nimport { ReturnBlock } from \"../ReturnBlock\";\n\n/**\n * Gets the y position of a shape\n */\nexport class GetYBlock extends ReturnBlock {\n    shape: ReturnBlock\n\n    /**\n     * Constructor\n     * @param id the id\n     * @param inputs inputs[0] is the get shape.\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id);\n        this.shape = inputs[0];\n    }\n\n    /**\n     * Returns y position.\n     * @param varEnv variable environment\n     */\n    evalBlock(varEnv: Map<string, any>){\n        let shapeName = this.shape.evalBlock(varEnv);\n\n        let shape: Shape = varEnv.get(shapeName);\n        \n        if(!shape) throw new TeaBlocksError('This shape does not exist', this.id);\n\n        return shape.posY;\n    }\n}","import { TeaBlocksError } from './../../TeaBlocksError';\nimport { ReturnBlock } from \"../ReturnBlock\";\nimport { VoidBlock } from \"../VoidBlock\";\nimport { Shape } from \"./Shape\";\n\n/**\n * Block for moving a shape.\n */\nexport class MoveBlock extends VoidBlock {\n    shape: ReturnBlock; // a GetShapeBlock, tho madlads can use constants that start with $.\n    x: ReturnBlock;\n    y: ReturnBlock;\n\n    /**\n     * Constructor\n     * @param inputs the inputs (shape is inputs[0]; x is inputs[1]; y is inputs[2])\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.shape = inputs[0];\n        this.x = inputs[1];\n        this.y = inputs[2];\n    }\n\n    /**\n     * Adds x and y to the position of the shape.\n     * @param varEnv variable environment\n     */\n    *evalBlock(varEnv: Map<string, any>) {\n        let shapeName: string = String(this.shape.evalBlock(varEnv));\n        let shape: Shape = varEnv.get(shapeName);\n\n        if(!shape) throw new TeaBlocksError('This shape does not exist', this.id);\n\n        let x = Number(this.x.evalBlock(varEnv));\n        let y = Number(this.y.evalBlock(varEnv));\n\n        if (isNaN(x)|| isNaN(y)) {\n            throw new TeaBlocksError(\"Input not a number\", this.id);\n        }\n\n        shape.posX += x;\n        shape.posY += y;\n\n        varEnv.set(shapeName, shape);\n\n        yield;\n    }\n\n\n}","import { TeaBlocksError } from './../../TeaBlocksError';\nimport { ReturnBlock } from \"../ReturnBlock\";\nimport { VoidBlock } from \"../VoidBlock\";\nimport { Shape } from \"./Shape\";\n\n/**\n * Block for rotating a shape (by degrees).\n */\nexport class RotateBlock extends VoidBlock {\n    shape: ReturnBlock; // a GetShapeBlock, tho madlads can use constants that start with $.\n    rot: ReturnBlock;\n\n    /**\n     * Constructor\n     * @param inputs the inputs (shape is inputs[0]; rotation is inputs[1])\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.shape = inputs[0];\n        this.rot = inputs[1];\n    }\n\n    /**\n     * Adds rot to the rotation of the shape.\n     * @param varEnv variable environment\n     */\n    *evalBlock(varEnv: Map<string, any>) {\n        let shapeName: string = String(this.shape.evalBlock(varEnv));\n        let shape: Shape = varEnv.get(shapeName);\n\n        if(!shape) throw new TeaBlocksError('This shape does not exist', this.id);\n\n        let rot = Number(this.rot.evalBlock(varEnv));\n\n        if (isNaN(rot)) {\n            throw new TeaBlocksError(\"Input not a number\", this.id);\n        }\n\n        shape.rot += rot;\n\n        varEnv.set(shapeName, shape);\n\n        yield;\n    }\n\n\n}","import { TeaBlocksError } from './../../TeaBlocksError';\nimport { ReturnBlock } from \"../ReturnBlock\";\nimport { VoidBlock } from \"../VoidBlock\";\nimport { Shape } from \"./Shape\";\n\n/**\n * Block for scaling a shape (multiplier).\n */\nexport class ScaleBlock extends VoidBlock {\n    shape: ReturnBlock; // a GetShapeBlock, tho madlads can use constants that start with $.\n    x: ReturnBlock;\n    y: ReturnBlock;\n\n    /**\n     * Constructor\n     * @param inputs the inputs (shape is inputs[0]; x is inputs[1]; y is inputs[2])\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.shape = inputs[0];\n        this.x = inputs[1];\n        this.y = inputs[2];\n    }\n\n    /**\n     * Multiplies x and y to the scale of the shape.\n     * @param varEnv variable environment\n     */\n    *evalBlock(varEnv: Map<string, any>) {\n        let shapeName: string = String(this.shape.evalBlock(varEnv));\n        let shape: Shape = varEnv.get(shapeName);\n\n        if(!shape) throw new TeaBlocksError('This shape does not exist', this.id);\n\n        let x = Number(this.x.evalBlock(varEnv));\n        let y = Number(this.y.evalBlock(varEnv));\n\n        if (isNaN(x) || isNaN(y)) {\n            throw new TeaBlocksError(\"Input not a number\", this.id);\n        }\n\n        shape.scaleX *= x;\n        shape.scaleY *= y;\n\n        varEnv.set(shapeName, shape);\n\n        yield;\n    }\n\n\n}","export enum ShapeType{\n    RECT='Rectangle',\n    CIRCLE='Circle',\n    TRIANGLE='Triangle',\n    STAR='Star',\n    HEART='Heart',\n}","import { InternalCompilerError } from './InternalCompilerError';\nimport { AbstractBlock } from \"./assemblyBlocks/AbstractBlock\";\nimport { VoidBlock } from \"./assemblyBlocks/VoidBlock\";\n\nvar interuptSignal = false; // stop signal\n\n/**\n * Class for a user-created program.\n */\nexport class Program {\n    subroutines: AbstractBlock[];\n    triggerDict: Map<string, number[]>;\n    varEnv: Map<string, any>;\n\n    triggeredIndexes: Set<number>;\n\n    taskQueue: [IterableIterator<void>, number][];\n\n    // function that gets called when an error happens. Should be injected\n    errorNotify: (message: string, ...nodeId: string[]) => void;\n\n    /**\n     * Constructor\n     * @param subroutines list of abstract block trees in order (including triggered subroutines)/\n     */\n    constructor(subroutines: AbstractBlock[], triggerDict: Map<string, number[]>) {\n        this.subroutines = subroutines;\n        this.triggerDict = triggerDict;\n        this.varEnv = new Map();\n        this.taskQueue = [];\n        this.errorNotify = (message: string, ...nodeId: string[]) => { console.log('Unhandled Runtime Error') };\n\n        this.triggeredIndexes = new Set();\n\n        triggerDict.forEach((ixArr) => {\n            ixArr.forEach(ix => this.triggeredIndexes.add(ix));\n        })\n\n        console.log('trigger map');\n        console.log(triggerDict);\n\n        console.log(`THERE ARE ${this.subroutines.length} subroutines`);\n    }\n\n    /**\n     * Runs the subroutines triggered by trigName, in order.\n     * Does not clear varEnv.\n     * \n     * @param trigName the name of the trigger\n     */\n    trigger(trigName: string): void {\n        // this.taskQueue = [];\n\n        if (!this.triggerDict.has(trigName)) {\n            console.log(`${trigName} is not a defined trigger`);\n            return;\n        }\n\n        this.triggerDict.get(trigName)?.forEach(t => {\n            let sub = this.subroutines[t];\n            if(!(sub instanceof VoidBlock)) throw new InternalCompilerError('Subroutine not Void!');\n            this.buildTaskQueue(sub.evalBlock(this.varEnv), sub.getLength());\n        });\n\n        this.scheduleNextTask();\n\n    }\n\n    /**\n     * Schedules execution of the program to stop.\n     */\n    stop() {\n        console.log('scheduling to stop!');\n        interuptSignal = true;\n    }\n\n\n    /**\n     * Schedules untriggered subroutines for execution.\n     */\n    run() {\n        interuptSignal = false;\n        this.taskQueue = []\n\n        this.varEnv = new Map();\n\n        this.subroutines.filter((val, ix) => !this.triggeredIndexes.has(ix))\n            .forEach(task => {\n                if(!(task instanceof VoidBlock)) throw new InternalCompilerError('Task is not a Void!');\n\n                let gen = task.evalBlock(this.varEnv);\n                this.buildTaskQueue(gen, task.getLength());\n            });\n\n        this.scheduleNextTask();\n\n    }\n\n    /**\n     * Adds a task to the task queue\n     * @param task task being added to queue\n     */\n    private buildTaskQueue(task: IterableIterator<void>, length: number) {\n        this.taskQueue.push([task, length]);\n    }\n\n    /**\n     * Recursive execution loop using requestAnimationFrame. Executsts the generator\n     * cycle. If the current generator is done, it asks for the next task.\n     * Stops executing if scheduled to stop.\n     * \n     * @param task current task being worked on\n     * @param length the number of steps to execute this task\n     */\n    private eventLoop(task: IterableIterator<void>, length: number) {\n        if (interuptSignal) {\n            this.stopCleanup();\n            return;\n        }\n        let status;\n\n        try {\n            let count = 0;\n            let s;\n\n            do {\n                s = task.next();\n            } while (++count < length);\n\n            status = s.done;\n\n        } catch (err) {\n            console.error(err);\n            console.log('CAUGHT AN ERROR')\n\n            interuptSignal = true;\n            this.taskQueue = [];\n\n            // eslint-disable-next-line eqeqeq\n            if (err.name == 'TeaBlocksError') {\n                console.log('TEABLOCKS ERROR!!!')\n                this.errorNotify(err.message, err.id);\n                console.log(err);\n            } else {\n                console.log('UNHANDLED ERROR!!');\n                throw err;\n            }\n\n        }\n\n        if (status) {\n            this.scheduleNextTask();\n        } else {\n            window.requestAnimationFrame(_ => this.eventLoop(task, length));\n            // setTimeout(_ => this.eventLoop(task, length), 0);\n        }\n    }\n\n    /**\n     * Schedules the next task for execution, if there is a next task.\n     */\n    private scheduleNextTask() {\n        let nextTask = this.taskQueue.shift();\n        if (nextTask == null) return;\n        let [aaa, length] = nextTask;\n        window.requestAnimationFrame(_ => this.eventLoop(aaa, length));\n        // setTimeout(_ => this.eventLoop(aaa, length),0)\n\n    }\n\n    private stopCleanup() {\n        this.varEnv = new Map();\n        this.taskQueue = [];\n    }\n}","import { AbstractBlock } from './assemblyBlocks/AbstractBlock';\nimport { Program } from './Program';\nimport { StateNode } from './state/StateNode';\nimport { createAssemblyBlock, BlockType } from './factory';\n\n/**\n * Compiles the StateNodes into Program.\n * \n * @param trees root nodes of trees (precompiled)\n * @returns a Program compiled from the root nodes\n */\nexport default async function compile(trees: StateNode[]) {\n\n    /**\n     * Compiles a single StateNode tree root node into a tree of AssemblyBlocks.\n     * Returns a set of all the names of triggers that trigger this tree.\n     * \n     * @param node node being compiled\n     * @returns a tuple of the corresponding abstract block for this node \n     *    (populated as a tree with children) and the set of trigger names for this tree.\n     */\n    function compileTree(node: StateNode): [AbstractBlock, Set<string>] {\n        console.log(\"Entering Compile Tree\");\n        if (node.hasBeenCompiled) throw new EvalError(\"Looping tree? (In Compiler)\");\n\n        node.hasBeenCompiled = true; // flags node as being compiled\n\n        if (node.isInput) {\n            console.log(\"We an input (base case)\");\n            let compiledNode: AbstractBlock = createAssemblyBlock(node.nodeId, node.blockType, ...node.constInputs);\n\n            let trigSet: Set<string> = new Set();\n            if (node.isTriggered) {\n                console.log(`${node.constInputs[0]} is this node's trigger`);\n                trigSet.add(node.constInputs[0]); //! 0th index is the trigger name\n            }\n\n            return [compiledNode, trigSet];\n        } else if (node.blockType === BlockType.IF || node.blockType === BlockType.WHILE) {\n            console.log(\"IF BLOCK/ WHILE BLOCK\");\n            let thisNodeChildren = node.children;\n            console.log(\"Length of children: \" + thisNodeChildren.length);\n            // let inputs: AbstractBlock[] = [];\n            let trigSet: Set<string> = new Set();\n\n            // inputs will be [[condition], [if], [else]]\n            let inputs = thisNodeChildren.map(childArr => {\n                let compiledArr = childArr.map(child => {\n                    console.log('Compiling child');\n                    let [compiledChild, trig] = compileTree(child);\n                    console.log('Done compiling child');\n\n                    trig.forEach(t => trigSet.add(t));\n\n                    return compiledChild;\n                });\n\n                return compiledArr;\n            });\n\n            console.log('Done compiling children');\n            let compiledNode = createAssemblyBlock(node.nodeId, node.blockType, ...node.constInputs, inputs); //! <---\n            console.log('Returning');\n\n            return [compiledNode, trigSet];\n\n        } else {     //todo other cases stuff\n            console.log(\"We not input (recursive)\");\n            let [thisNodeChildren] = node.children;\n            console.log(\"Length of children: \" + thisNodeChildren.length);\n            let inputs: AbstractBlock[] = [];\n            let trigSet: Set<string> = new Set();\n\n            for (let child of thisNodeChildren) {\n                console.log('Compiling child');\n                let [compiledChild, trig] = compileTree(child);\n                console.log('Done compiling child');\n\n                inputs.push(compiledChild);\n                trig.forEach(t => trigSet.add(t));\n            }\n\n            if (node.isTriggered) {\n                // this can't happen because only inputs are triggered\n                // may be deleted later when finalized\n                trigSet.add(node.constInputs[0]);\n            }\n\n            console.log('Done compiling children');\n            let compiledNode = createAssemblyBlock(node.nodeId, node.blockType, ...node.constInputs, inputs); //! <---\n            console.log('Returning');\n\n            return [compiledNode, trigSet];\n        }\n\n    }\n\n    let subroutines: AbstractBlock[] = Array(trees.length);\n    let triggerDict: Map<string, number[]> = new Map();\n\n    console.log('BEGINING COMPILING');\n    console.log('We have ' + trees.length + ' trees');\n\n    for (let ix = 0; ix < trees.length; ix++) {\n        console.log('COMPILING THIS NODE');\n        let [subroutine, trigSet] = compileTree(trees[ix]);\n        console.log('DONE COMPILING THIS NODE');\n        subroutines[ix] = subroutine;\n\n        console.log(`Trigset:`);\n        console.log(trigSet);\n\n        trigSet.forEach(trig => {\n            console.log('Trig:' + trig);\n            if (triggerDict.has(trig)) {\n                triggerDict.get(trig)?.push(ix);\n            } else {\n                triggerDict.set(trig, [ix]);\n            }\n        })\n\n\n    }\n\n\n    return new Program(subroutines, triggerDict);\n}","import React, { useRef, useEffect } from 'react'\n\n// https://medium.com/@pdx.lucasm/canvas-with-react-js-32e133c05258\nconst Canvas = props => {\n\n    const { draw, ...rest } = props\n    const canvasRef = useRef(null)\n\n    useEffect(() => {\n\n        const canvas = canvasRef.current\n        const context = canvas.getContext('2d')\n        let frameCount = 0\n        let animationFrameId\n\n        // https://stackoverflow.com/questions/10214873/make-canvas-as-wide-and-as-high-as-parent\n        \n        // Make it visually fill the positioned parent\n        canvas.style.width = '100%';\n        canvas.style.height = '100%';\n\n        // ...then set the internal size to match\n        canvas.width = canvas.offsetWidth;\n        canvas.height = canvas.offsetHeight;\n\n        const render = () => {\n            frameCount++\n            draw(context, frameCount)\n            animationFrameId = window.requestAnimationFrame(render)\n        }\n        render()\n\n        return () => {\n            window.cancelAnimationFrame(animationFrameId)\n        }\n    }, [draw])\n\n    return <canvas ref={canvasRef} {...rest} />\n}\n\nexport default Canvas","import {  Component } from 'react'\nimport { Joystick } from 'react-joystick-component';\nimport { AssemblyJoystick } from '../compiler/assemblyBlocks/inputBlocks';\nimport { IJoystickUpdateEvent } from 'react-joystick-component/build/lib/Joystick';\nimport { Shape } from '../compiler/assemblyBlocks/shape/Shape';\nimport { ShapeType } from '../compiler/assemblyBlocks/shape/ShapeType';\nimport { Program } from '../compiler/Program';\nimport Canvas from './Canvas';\nimport '../styles/Runtime.scss';\nimport ReactDOM from 'react-dom';\n\n\ninterface Prop {\n    program: Program;\n}\n\ninterface State {\n    inputs: any[]\n}\n\n// let lastX = 0;\n// let lastY = 0;\n\ninterface InputValue {\n    started: boolean,\n    x: number,\n    y: number\n}\n\nexport default class Runtime extends Component<Prop, State> {\n    program: Program;\n    inputStorage: Map<string, InputValue>;\n\n    constructor(props: Prop) {\n        super(props);\n        console.log(\"--RUNTIME           Entered Runtime constructor\");\n        this.state = ({\n            inputs: []\n        });\n        this.program = props.program;\n        this.inputStorage = new Map();\n\n        this.draw = this.draw.bind(this);\n        this.setup = this.setup.bind(this);\n\n    }\n\n    moveThing(inputVal: InputValue, inputName: string) {\n        // console.log(inputVal, inputName);\n        if (inputVal.started) {\n            let newJoy: AssemblyJoystick = { x: inputVal.x, y: inputVal.y };\n            this.program.varEnv.set(`&${inputName}`, newJoy);\n            this.program.trigger(`${inputName}`); //! hope this work\n        }\n    }\n\n\n    setup() {\n        console.log(\"--RUNTIME           called setup !!!!\", this.program.varEnv, this.program.triggerDict, \"asdasd\");\n        if (this.program.triggerDict.size === this.state.inputs.length) return;\n\n        this.program.varEnv.forEach((value: any, key: string) => {\n            let joystickName = key.substring(1); // gets rid of the $\n            if (value.type === \"joy\" && !this.inputStorage.has(joystickName)) {\n                console.log(\"--RUNTIME           \", value);\n\n\n                let joystick =\n                    (<div className={joystickName} style={{ position: 'absolute', left: value.x, bottom: value.y }} key={joystickName}>\n                        <Joystick\n                            size={100}\n                            baseColor=\"#7c7cf3\"\n                            stickColor=\"#efefef\"\n                            move={(e: IJoystickUpdateEvent) => { this.handleMove(e, joystickName) }}\n                            stop={(e: IJoystickUpdateEvent) => { this.handleStop(e, joystickName) }}\n                            start={(e: IJoystickUpdateEvent) => { this.handleStart(e, joystickName) }}>\n                        </Joystick>\n                    </div>);\n\n                let inpVal: InputValue = {\n                    started: false,\n                    x: 0,\n                    y: 0\n                }\n\n                this.inputStorage.set(joystickName, inpVal)\n                this.setState(prevState => ({\n                    inputs: [...prevState.inputs, joystick]\n                }))\n                this.program.varEnv.set(`&${joystickName}`, { x: 0, y: 0 });\n\n            } else if (value.type === \"btn\") {\n                // todo: haven't implemented yet \n            }\n        })\n    }\n\n    componentDidMount() {\n        this.setup();\n    }\n\n    draw(ctx: CanvasRenderingContext2D, frameCount: number) {\n        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n        if (this.state.inputs.length < this.program.triggerDict.size) {\n            this.setup();\n        }\n\n        this.inputStorage.forEach((value: InputValue, key: string) => {\n            this.moveThing(value, key);\n        })\n\n\n        if (this.program.subroutines.length > 0) { // Check if the program compiled   \n            this.program.varEnv.forEach((value, key: string) => {\n                switch (value.constructor) {\n                    case Shape:\n                        this.addShape(ctx, value);\n                        break;\n                    default:\n                }\n            });\n        }\n    }\n\n    handleMove(e: IJoystickUpdateEvent, inputName: string) {\n        if (e.x && e.y) {\n            if (this.inputStorage.get(inputName)) {\n                let newVals: InputValue = { started: this.inputStorage.get(inputName)?.started || true, x: e.x / 50, y: - 1 * (e.y / 50) };\n                this.inputStorage.set(inputName, newVals);\n            }\n        }\n    }\n\n    handleStop(e: IJoystickUpdateEvent, inputName: string) {\n        let newVals: InputValue = { started: false, x: 0, y: 0 }\n        this.inputStorage.set(inputName, newVals);\n    }\n\n    handleStart(e: IJoystickUpdateEvent, inputName: string) {\n        if (this.inputStorage.get(inputName)) {\n            let newVals: InputValue = { started: true, x: this.inputStorage.get(inputName)?.x || 0, y: this.inputStorage.get(inputName)?.y || 0 }\n            this.inputStorage.set(inputName, newVals);\n        }\n    }\n\n    addShape(ctx: CanvasRenderingContext2D, element: Shape) {\n        let shapeType: ShapeType = element.type;\n        ctx.fillStyle = element.color;\n        switch (shapeType) {\n            case ShapeType.RECT:\n                this.addRect(ctx, element.posX, element.posY, element.scaleX, element.scaleY);\n                break;\n            case ShapeType.CIRCLE:\n                // addCircle(ctx, element.posX, element.posY, element.scaleX, element.scaleY);\n                break;\n            case ShapeType.TRIANGLE:\n                // addTriangle(ctx, element.posX, element.posY, element.scaleX, element.scaleY);\n                break;\n            case ShapeType.HEART:\n                // addHeart(ctx, element.posX, element.posY, element.scaleX, element.scaleY);\n                break;\n            case ShapeType.STAR:\n                // addStar(ctx, element.posX, element.posY, element.scaleX, element.scaleY);\n                break;\n            default:\n                // console.log('default');\n                break;\n        }\n\n    }\n\n    addRect(ctx: CanvasRenderingContext2D, x: number, y: number, w: number, h: number) {\n        ctx.beginPath()\n        ctx.rect(x, y, w, h);\n        ctx.fill();\n    }\n\n    componentWillUnmount() {\n        let comp = document.getElementById('controller');\n        if (comp) {\n            ReactDOM.unmountComponentAtNode(comp);\n        }\n    }\n\n    render() {\n        return (\n            <div className=\"runtime-section\">\n                <div className=\"runtime-output\">\n                    <Canvas draw={this.draw} />\n                    <div className=\"controller\">\n                        {this.state.inputs}\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n\n","import { BlockType } from './../factory/BlockType';\n\n/**\n * A node of a State tree. The state tree represents the user program as precompiled by the precompiler\n * from the diagram schema. A tree made of these nodes is then passed to the compiler to assemble\n * the assemblyBlocks.\n */\nexport class StateNode {\n    nodeId: string;\n    children: StateNode[][];\n    blockType: BlockType;\n    constInputs: any[];\n    hasBeenCompiled: boolean;\n    isInput: boolean;\n    isTriggered: boolean;\n\n    /**\n     * Constructor.\n     * @param nodeId the id of the corresponding node in diagram schema\n     * @param blockType the type of the corresponding AssemblyBlock\n     * @param constInputs constant (static) inputs needed conr constructing AssemblyBloc\n     * @param isInput true iff this is an input node (without children)\n     */\n    constructor(nodeId: string, blockType: BlockType, constInputs: any[], isInput: boolean) {\n        this.nodeId = nodeId;\n        this.blockType = blockType;\n        this.children = [];\n        this.hasBeenCompiled = false;\n        this.isInput = isInput;\n        this.constInputs = constInputs;\n\n        // todo this needs to be updated when more triggered blocks are added\n        this.isTriggered = blockType === BlockType.BTN_STATUS ||\n            blockType === BlockType.JOY_X ||\n            blockType === BlockType.JOY_Y;\n    }\n}","import { BlockType } from '../compiler/factory/BlockType';\nimport { StateNode } from '../compiler/state/StateNode';\nimport { CustomSchema } from '../diagram/CustomSchema';\nimport { CustomNode } from '../codeBlocks/CustomNode';\nimport { InputNode } from '../codeBlocks/InputNode';\n\nconst RECURSIVE_MAX_DEPTH: number = 500;\n\n/**\n * Sorts roots by grouping them into 25 pixel wide columns based on x coordinate.\n * Sorts groups by horizontal coordinate.\n * Sorts roots inside the groups by vertical coordinate.\n * Merges groups into 1D array in order.\n * \n * @param roots array of roots being sorted. (modifies)\n */\nfunction sortRoots(roots: CustomNode[]): CustomNode[] {\n    roots.sort((a, b) => {\n        return a.coordinates[0] - b.coordinates[0]\n    });\n\n    let groups: CustomNode[][] = [];\n    let groupTracker: [[number, number], number][] = [[[0, 20], 0]];\n\n    for (const root of roots) {\n        let xVal = root.coordinates[0];\n\n        for (var [range, ix] of groupTracker) {\n            if (range[0] <= xVal && xVal < range[1]) {\n                groups[ix].push(root);\n                break;\n            }\n        }\n\n        groupTracker.push([[xVal - 5, xVal + 20], ix + 1]);\n        groups[ix + 1] = [root];\n    }\n\n    groups.map(group => {\n        group.sort((a, b) => a.coordinates[1] - b.coordinates[1])\n        return group;\n    });\n\n\n    return groups.flat();\n}\n\n\n/**\n * Precompiles schema of a diagram into an array of StateNode trees,\n * in order. This array is made compatible to be compiled by the\n * compiler.\n * \n * The precompiler is lazy: only output nodes and nested nodes\n * (such as IF, WHILE, etc.) are considered as root nodes. If\n * a node is not connected to a root node, it is exluded.\n * \n * @param schema map of all diagram schemas in the program (must include 'main')\n * @return state node tree array.\n */\nfunction precompile(schemas: Map<string, CustomSchema>): StateNode[] {\n    console.log(schemas);\n    let ms = schemas.get('main');\n    console.log(ms);\n    let mainSchema: CustomSchema;\n    if (!ms) {\n        throw Error('Main schema must be in schemas')\n    } else {\n        mainSchema = ms;\n    }\n\n    /**\n     * Returns the root nodes of a schema if there are any.\n     * A root is any node that does not have output ports, such\n     * as OutputNodes, IFNodes, NestNodes, etc.\n     * \n     * The roots are sorted by their coordinates. Sorting is based\n     * on horizontal difference. If absolute horizontal difference of \n     * a pair of roots is less than 15, then the pair is ordered by\n     * vertical difference.\n     * \n     * @param schema the schema.\n     * @return root nodes of schema.\n     */\n    function getRoots(schema: CustomSchema): CustomNode[] {\n        let roots: CustomNode[] = [];\n        if (schema.links == null) return roots;\n\n        roots = schema.nodes.filter(node => 'isRoot' in node)\n            // avoids duplicate nodes\n            .filter(function (node: CustomNode, index: number, arr: CustomNode[]) {\n                return arr.indexOf(node) === index;\n            });\n\n        let sorte = sortRoots(roots);\n\n        console.log('roots');\n        console.log(sorte);\n        return sorte;\n    }\n\n    /**\n     * Recursive precompiler helper. Precompiles a root CustomNode and its children recursively.\n     * @param root\n     */\n    function precompRoot(root: CustomNode, depth: number = 0, schema: CustomSchema = mainSchema): StateNode {\n        if (depth >= RECURSIVE_MAX_DEPTH) throw new Error('Looping Tree?\\nReached max recursion depth: ' + RECURSIVE_MAX_DEPTH);\n        depth += 1;\n\n\n        if (isInput(root)) {\n            // base case\n            let comp = new StateNode(root.id, root.blockType, root.constInputs, true);\n            console.log(`Triggered: ${comp.isTriggered}`);\n            return comp;\n\n        } else if (root.blockType === BlockType.IF) {\n            // getting if children\n            let ifSchema = schemas.get(root.id + 'if');\n            if (!ifSchema) throw Error('Encountered If Node without schema');\n            let ifSchemaRoots: CustomNode[] = getRoots(ifSchema);\n\n            let ifChildren: StateNode[] = [];\n\n            for (let innerRoot of ifSchemaRoots) {\n                let compChild = precompRoot(innerRoot, depth, ifSchema);\n                ifChildren.push(compChild);\n            }\n\n            // getting else children\n            let elseSchema = schemas.get(root.id + 'else');\n            if (!elseSchema) throw Error('Encountered If Node without schema');\n            let elseSchemaRoots: CustomNode[] = getRoots(elseSchema);\n\n            let elseChildren: StateNode[] = [];\n\n            for (let innerRoot of elseSchemaRoots) {\n                let compChild = precompRoot(innerRoot, depth, elseSchema);\n                elseChildren.push(compChild);\n            }\n\n            // getting condition\n            let condition = getChildren(root, schema);\n            let compiledCondition = condition.map(child => precompRoot(child, depth, schema));\n\n            // putting it all together\n            let leIf: StateNode = new StateNode(root.id, BlockType.IF, [], false);\n            leIf.children = [compiledCondition, ifChildren, elseChildren];\n            return leIf;\n\n        } else if (root.blockType === BlockType.WHILE) {\n            // compiling while block\n            let whileSchema = schemas.get(root.id + 'while');\n            if (!whileSchema) throw Error('Encountered Nested Node without schema');\n            let whileSchemaRoots: CustomNode[] = getRoots(whileSchema);\n\n            let compiledWhile: StateNode[] = [];\n\n            for (let innerRoot of whileSchemaRoots) {\n                let compChild = precompRoot(innerRoot, depth, whileSchema);\n                compiledWhile.push(compChild);\n            }\n\n            //compiling condition\n            let condition = getChildren(root, schema);\n            console.log(\"my children before precompiling: \");\n            console.log(condition);\n            let compiledCondition = condition.map(child => precompRoot(child, depth, schema));\n\n\n\n            let compNest = new StateNode(root.id, BlockType.WHILE, [], false);\n            compNest.children = [compiledCondition, compiledWhile];\n\n            return compNest;\n\n        } else {\n            let myChildren = getChildren(root, schema);\n            console.log(\"my children before precompiling: \");\n            console.log(myChildren);\n            let compiledChildren = myChildren.map(child => precompRoot(child, depth, schema));\n            console.log(\"my children after precompiling: \");\n            console.log(compiledChildren);\n            let comp = new StateNode(root.id, root.blockType, root.constInputs, false);\n            comp.children = [compiledChildren];\n            console.log('value of comp\\'s children: ');\n            console.log(comp.children);\n\n            return comp;\n        }\n\n    }\n\n\n    /**\n     * Returns children of this node.\n     * @param root root node (not an input node)\n     * @param schema the schema that this node is in\n     */\n    function getChildren(root: CustomNode, schema: CustomSchema = mainSchema): CustomNode[] {\n        if (!schema.nodes.includes(root)) throw Error('This node is not in schema');\n\n        console.log(\"GETTING CHILDREN!\");\n        let children: CustomNode[] = [];\n        if (root.inputs == null) return [];\n\n\n        let portIds = root.inputs.map(port => port.id);\n        console.log(portIds);\n\n        portIds.sort();\n\n        console.log('port ids');\n        console.log(portIds);\n\n        if (portIds != null) {\n            let childrenOutputPorts = portIds.map(id=> schema.links.find(link=>link.input===id)?.output);\n            for (let portId of childrenOutputPorts) {\n                console.log('Found a child');\n                if(portId == null) throw new Error('Null port id!');\n                let nodeId = portId.substring(0, portId.indexOf(\"-output\"));\n                let child = schema.nodes.find(node => node.id === nodeId);\n                if (child != null) children.push(child);\n            }\n        }\n        return children;\n\n    }\n\n    /**\n     * Determines if the node is an input node. At the moment, only\n     * instances of InputNode are considered to be inputs.\n     * \n     * @param node the node\n     */\n    function isInput(node: CustomNode): boolean {\n        return node instanceof InputNode;\n    }\n\n\n\n    let precompiledStuff = getRoots(mainSchema).map(root => precompRoot(root));\n    console.log('Done precompiling! here\\'s what we have:');\n    console.log(precompiledStuff);\n    return precompiledStuff;\n\n}\n\n\n\nconst Precompiler = {\n    sortRoots,\n    precompile\n}\n\n\nexport default Precompiler;","import { SchemaSave } from './SchemaSave';\nimport { CustomSchema } from './../diagram/CustomSchema';\nimport { BlockType } from '../compiler/factory';\nimport DiagramIDE from \"../ide/DiagramIDE\";\nimport { CustomRender, IfRender, WhileRender } from '../diagram/renders';\n\nexport class SchemaSerializor {\n\n    public static serialize(): string {\n        let save: SchemaSave = {\n            ids: [],\n            schemas: [],\n            nodeIDStart: DiagramIDE.getID()\n        };\n\n        DiagramIDE.getIDE().validatedSchemas.forEach((value, key) => {\n            save.ids.push(key);\n            save.schemas.push(value);\n        })\n\n        return JSON.stringify(save);\n    }\n\n    public static deserialize(json: string): [Map<string, CustomSchema>, string] {\n        let save = JSON.parse(json) as SchemaSave;\n\n        let valSchemas = new Map();\n\n        for (let i = 0; i < save.ids.length; i++) {\n            let schema = save.schemas[i];\n\n            schema.nodes.forEach(node => {\n                switch (node.blockType) {\n                    case BlockType.IF:\n                        node.render = IfRender;\n                        break;\n                    case BlockType.WHILE:\n                        node.render = WhileRender;\n                        break;\n                    default:\n                        node.render = CustomRender;\n                }\n            });\n\n            valSchemas.set(save.ids[i], schema);\n        }\n\n        return [valSchemas, save.nodeIDStart];\n    }\n}","import { useState, useEffect } from 'react';\nimport DiagramIDE from './DiagramIDE';\nimport { Button } from 'beautiful-react-ui';\nimport compile from '../compiler/Compiler';\nimport { Program } from '../compiler/Program';\nimport Runtime from '../runtime/Runtime';\nimport Precompiler from './Precompiler';\nimport { SchemaSerializor } from '../serializor/SchemaSerializor';\nimport { TeaBlocksError } from '../compiler/TeaBlocksError';\nimport '../styles/Ide.scss';\nimport ReactDOM from 'react-dom';\n\nconst ideId = 'ide';\nconst emptyProgram = new Program([], new Map());\n\n/**\n * The react component containing the IDE of the TeaBlocks app. This class\n * encapsulates DiagramIDE.\n */\nexport default function AppDiagram() {\n    const [program, setProgram] = useState<Program>(emptyProgram);\n\n    useEffect(() => {\n        DiagramIDE.getIDE().renderDiagram();\n    }, []);\n\n    useEffect(() => {\n        let rtElem = document.getElementById('Runtime');\n        if (rtElem) {\n            console.log('UNMOUNTING RUNTIME');\n            ReactDOM.unmountComponentAtNode(rtElem);\n        }\n\n        if (program !== emptyProgram) {\n            console.log('MOUNTING RUNTIME');\n\n            ReactDOM.render((\n                <Runtime program={program} />\n            ), document.getElementById('Runtime'));\n        }\n\n        return () => {\n            console.log('Cleanup?')\n            program.stop();\n        }\n    }, [program])\n\n    function build() {\n        console.log('Button compile and run');\n        DiagramIDE.getIDE().unflagNodes();\n\n        let precomp = Precompiler.precompile(DiagramIDE.getIDE().validatedSchemas);\n\n        compile(precomp).then(prog => {\n            prog.errorNotify = errorNotify;\n            setProgram(prog);\n        }).catch(err => {\n            console.error(err);\n        })\n    }\n\n    function runProg() {\n        program.varEnv.set('&joy-joystick', { x: 0, y: 0 }); //! remove later\n\n        console.log('Run Program');\n\n        try {\n            program.run();\n        } catch (err) {\n            if (err instanceof TeaBlocksError) {\n                console.error(err);\n                DiagramIDE.getIDE().flagNodes(err.id);\n            } else {\n                throw err;\n            }\n        }\n    }\n\n    function errorNotify(message: string, ...nodeId: string[]): void {\n        DiagramIDE.getIDE().flagNodes(...nodeId);\n        DiagramIDE.getIDE().redrawDiagram();\n    }\n\n    function goHome() {\n        DiagramIDE.getIDE().setDisplaySchemaId('main');\n    }\n\n    function load() {\n        let json = prompt('Paste the JSON for validatedSchemas:', '');\n        let [val, nID] = SchemaSerializor.deserialize(json ? json : '');\n        DiagramIDE.getIDE().loadSchemas(val, nID);\n    }\n\n\n    return (\n        <div className=\"grid-container\">\n            <div className=\"Ide\">\n\n                <div id={ideId} />\n                <Button color=\"primary\" icon=\"home\" onClick={goHome} className=\"compile-btn\"> Go to Main</Button>\n                <Button color=\"primary\" icon=\"hammer\" onClick={() => { build() }} className=\"compile-btn\"> Build</Button>\n                <Button color=\"primary\" icon=\"play\" onClick={() => runProg()} className=\"compile-btn\"> Run</Button>\n                <Button color=\"primary\" icon=\"stop\" onClick={program.stop} className=\"compile-btn\"> Stop</Button>\n                <Button color=\"primary\" icon=\"save\" onClick={() => { console.log(SchemaSerializor.serialize()) }} className=\"compile-btn\"> Save</Button>\n                <Button color=\"primary\" icon=\"upload\" onClick={load} className=\"compile-btn\"> Load</Button>\n            </div>\n            <div className=\"Runtime\" id=\"Runtime\">\n            </div>\n        </div>\n    )\n}\n","import React from 'react';\nimport './styles/App.scss';\nimport AppDiagram from './ide/AppDiagram';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h1>TeaBlocks Demo (WIP)</h1>\n      <AppDiagram />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","import { ShapeColor } from './ShapeColor';\nimport { ShapeType } from \"./ShapeType\";\n\nexport class Shape {\n    shapeName: string;\n    posX: number;\n    posY: number;\n    scaleX: number;\n    scaleY: number;\n    rot: number;\n    type: ShapeType;\n    color: ShapeColor;\n\n\n    /**\n     * Constructor\n     * @param shapeName shape name.\n     * @param type type of shape enum.\n     * @param color the color of shape enum.\n     * @param posX initial x positon.\n     * @param posY initial y positon.\n     * @param scaleX initial x scale.\n     * @param scaleY initial y scale.\n     * @param rot rotation in degrees.\n     */\n    constructor(shapeName: string,\n        type: ShapeType,\n        color: ShapeColor,\n        posX: number,\n        posY: number,\n        scaleX: number,\n        scaleY: number,\n        rot: number) {\n        this.shapeName = shapeName;\n        this.posX = posX;\n        this.posY = posY;\n        this.scaleX = scaleX;\n        this.scaleY = scaleY;\n        this.rot = rot;\n        this.type = type;\n        this.color = color;\n    }\n\n\n\n}","import { NodeData } from './NodeData';\nimport { BlockType } from './../compiler/factory/BlockType';\nimport { Node, NodeCoordinates, Port } from 'beautiful-react-diagrams/@types/DiagramSchema';\nimport { ElementType, ReactNode } from 'react';\nimport { CustomNode } from './CustomNode';\nimport { GuranteedRoot } from './GuranteedRoot';\nimport DiagramIDE from '../ide/DiagramIDE';\n\n\nexport class OutputNode extends GuranteedRoot implements CustomNode {\n    id: string;\n    coordinates: NodeCoordinates;\n    content: ReactNode;\n    inputs: Port[];\n    data: NodeData;\n    render: (props: Omit<Node<any>, 'coordinates'>) => ElementType | ReactNode;\n    blockType: BlockType;\n    constInputs: any[];\n\n    /**\n     * \n     * @param content content of this node\n     * @param coordinates inital coordinates of the node\n     * @param numInputs the number of input ports this node should have\n     * @param blockType the type of the assembly block created (for phasing out assConstructor)\n     * @param constInputs constant inputs that assembly block takes.\n     * @param data data of the node (any object; should contain assConstructor)\n     * @param render renderer used to render\n     * ! ^ data is kinda weird. need to figure out how to replace it with more concrete/safe types.\n     */\n    constructor(content: ReactNode,\n        coordinates: NodeCoordinates,\n        numInputs: number,\n        blockType: BlockType,\n        constInputs: any[],\n        data: NodeData,\n        render: (props: Omit<Node<any>, 'coordinates'>) => ElementType | ReactNode) {\n        super();\n        this.id = DiagramIDE.getID()\n        this.coordinates = coordinates;\n        this.content = content;\n        this.data = data;\n        this.render = render;\n\n        this.blockType = blockType;\n        this.constInputs = constInputs;\n\n        console.log('Outputs id: ' + this.id);\n\n        this.inputs = [];\n        for (let i = 0; i < numInputs; i++) {\n            let portId: string = `${this.id}-input-${i}`\n            console.log('port id: ' + portId);\n            let port: Port = { id: portId };\n            this.inputs.push(port);\n        }\n    }\n\n\n\n}","import { ControlType } from './ControlType';\n\n/**\n * A data type (bean) for a UI Input Element.\n */\nexport class ControlElement {\n    displayName: string;\n    x: number;\n    y: number;\n    type: ControlType;\n\n    /**\n     * Constructor\n     * @param displayName the display name of the shape (what the user specifies).\n     * @param x x position\n     * @param y y position\n     * @param type type of control\n     */\n    constructor(displayName:string,x: number, y: number, type: ControlType) {\n        this.displayName = displayName\n        this.x = x;\n        this.y = y;\n        this.type = type;\n    }\n}","import { ControlElement } from './ControlElement';\nimport { TeaBlocksError } from './../../TeaBlocksError';\nimport { ControlType } from './ControlType';\nimport { VoidBlock } from \"../VoidBlock\";\nimport { ReturnBlock } from '../ReturnBlock';\n\n/**\n * Like the MakeShapeBlock. Creates and assigns an a ControlElement object to \n * $elemName in the varEnv. Does not draw the variable itself.\n */\nexport class MakeControlElementBlock extends VoidBlock {\n    x: ReturnBlock;\n    y: ReturnBlock;\n    elemName: string;\n    type: ControlType;\n\n    /**\n     * Constructor.\n     * @param id id of statenode\n     * @param type the type of ui element\n     * @param elemName the display name of the ui element (what user specifies)\n     * @param inputs inputs[0] is x; input[1] is y\n     */\n    constructor(id: string, type: ControlType, elemName: string, inputs: ReturnBlock[]) {\n        super(id);\n        this.type = type;\n        this.elemName = elemName;\n        this.x = inputs[0];\n        this.y = inputs[1];\n    }\n\n\n    *evalBlock(varEnv: Map<string, any>) {\n        let x = Number(this.x.evalBlock(varEnv));\n        let y = Number(this.y.evalBlock(varEnv));\n\n        if (isNaN(x) || isNaN(y)) throw new TeaBlocksError('Position must be a number', this.id);\n\n        let elem = new ControlElement(this.elemName, x, y, this.type);\n\n        varEnv.set('$' + this.elemName, elem);\n        yield;\n    }\n\n}","import { ReturnBlock } from \"../ReturnBlock\";\nimport { VoidBlock } from \"../VoidBlock\";\n\n/**\n * Internal use.\n */\nexport class ConsoleLogBlock extends VoidBlock {\n    input;\n\n    /**\n     * Constructor\n     * @param input array of return blocks being printed\n     */\n    constructor(id: string, input: ReturnBlock[]) {\n        super(id)\n        console.log(\"this is the input\", input)\n        this.input = input;\n    }\n\n    *evalBlock(varEnv: Map<string, any>){\n        this.input.forEach(inp => {\n            let val = inp.evalBlock(varEnv);\n            console.log(val);\n        });\n        yield;\n\n    }\n}","import { ReturnBlock } from \"../../../ReturnBlock\";\n\n/**\n * \"Equal\" block.\n */\nexport class EQBlock extends ReturnBlock {\n    leftSide;\n    rightSide;\n\n    /**\n     * Constructor\n     * @param inputs the inputs of comparison (inputs[0] is left; inputs[1] is right)\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.leftSide = inputs[0];\n        this.rightSide = inputs[1];\n    }\n\n    /**\n     * Compares left and right side, returns true if \"leftSide == rightSide\"\n     * @param varEnv the variable envornment\n     */\n    evalBlock(varEnv: Map<string, any>): boolean {\n        let ls = this.leftSide.evalBlock(varEnv);\n        let rs = this.rightSide.evalBlock(varEnv);\n\n        // eslint-disable-next-line eqeqeq\n        return ls == rs;\n    }\n}","import { ReturnBlock } from \"../../../ReturnBlock\";\n\n/**\n * \"Greater than or equal\" block.\n */\nexport class GEQBlock extends ReturnBlock {\n    leftSide;\n    rightSide;\n\n    /**\n     * Constructor\n     * @param inputs the inputs of comparison (inputs[0] is left; inputs[1] is right)\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.leftSide = inputs[0];\n        this.rightSide = inputs[1];\n    }\n    /**\n     * Compares left and right side, returns true if \"leftSide >= rightSide\"\n     * @param varEnv the variable envornment\n     */\n    evalBlock(varEnv: Map<string, any>) {\n        let ls = this.leftSide.evalBlock(varEnv);\n        let rs = this.rightSide.evalBlock(varEnv);\n\n        return ls >= rs;\n    }\n}","import { ReturnBlock } from \"../../../ReturnBlock\";\n\n/**\n * \"Greater than\" block.\n */\nexport class GTBlock extends ReturnBlock {\n    leftSide;\n    rightSide;\n\n    /**\n     * Constructor\n     * @param inputs the inputs of comparison (inputs[0] is left; inputs[1] is right)\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.leftSide = inputs[0];\n        this.rightSide = inputs[1];\n    }\n\n    /**\n     * Compares left and right side, returns true if \"leftSide > rightSide\"\n     * @param varEnv the variable envornment\n     */\n    evalBlock(varEnv: any) {\n        let ls = this.leftSide.evalBlock(varEnv);\n        let rs = this.rightSide.evalBlock(varEnv);\n\n        return ls > rs;\n    }\n}","import { ReturnBlock } from \"../../../ReturnBlock\";\n\n/**\n * \"Less than or equal\" block.\n */\nexport class LEQBlock extends ReturnBlock {\n    leftSide;\n    rightSide;\n\n   /**\n     * Constructor\n     * @param inputs the inputs of comparison (inputs[0] is left; inputs[1] is right)\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.leftSide = inputs[0];\n        this.rightSide = inputs[1];\n    }\n\n    /**\n     * Compares left and right side, returns true if \"leftSide <= rightSide\"\n     * @param varEnv the variable envornment\n     */\n    evalBlock(varEnv: Map<string, any>) {\n        let ls = this.leftSide.evalBlock(varEnv);\n        let rs = this.rightSide.evalBlock(varEnv);\n\n        return ls <= rs;\n    }\n}","import { ReturnBlock } from \"../../../ReturnBlock\";\n\n/**\n * \"Less than\" block.\n */\nexport class LTBlock extends ReturnBlock {\n    leftSide;\n    rightSide;\n\n    /**\n     * Constructor\n     * @param inputs the inputs of comparison (inputs[0] is left; inputs[1] is right)\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id);\n        this.leftSide = inputs[0];\n        this.rightSide = inputs[1];\n    }\n\n    /**\n     * Compares left and right side, returns true if \"leftSide < rightSide\"\n     * @param varEnv the variable envornment\n     */\n    evalBlock(varEnv: Map<string, any>) {\n        let ls = this.leftSide.evalBlock(varEnv);\n        let rs = this.rightSide.evalBlock(varEnv);\n\n        return ls < rs;\n    }\n}","import { ReturnBlock } from \"../../../ReturnBlock\";\n\n/**\n * Boolean AND operation\n */\nexport class ANDBlock extends ReturnBlock {\n    inputs;\n\n    /**\n     * Constructor\n     * @param inputs the inputs being processed\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.inputs = inputs;\n    }\n\n    /**\n     * Performs boolean AND operation on inputs\n     * @param varEnv the variable envornment\n     */\n    evalBlock(varEnv: Map<string, any>): boolean {\n        for(let inp of this.inputs){\n            let val = Boolean(inp.evalBlock(varEnv));\n            if (!val){\n                return false;\n            }\n        }\n\n        return true;\n    }\n}","import { ReturnBlock } from \"../../../ReturnBlock\";\n\n/**\n * The boolean NOT\n */\nexport class NOTBlock extends ReturnBlock {\n    bool;\n\n    /**\n     * Constructor\n     * @param inputs the inputs (only cares about inputs[0]).\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.bool = inputs[0];\n    }\n\n    /**\n     * Performs boolean NOT operation on input.\n     * @param varEnv the variable envornment\n     */\n    evalBlock(varEnv: Map<string, any>): boolean {\n        let input = Boolean(this.bool.evalBlock(varEnv));\n        return !input;\n    }\n}","import { ReturnBlock } from \"../../../ReturnBlock\";\n\n/**\n * Boolean OR operation\n */\nexport class ORBlock extends ReturnBlock {\n    inputs;\n\n    /**\n     * Constructor\n     * @param inputs the inputs being processed\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.inputs = inputs;\n    }\n\n    /**\n     * Performs boolean OR operation on inputs\n     * @param {Map} varEnv the variable envornment\n     */\n    evalBlock(varEnv: Map<string, any>): boolean {\n        for (let inp of this.inputs) {\n            let val = Boolean(inp.evalBlock(varEnv));\n            if (val) return true;\n        }\n        return false;\n    }\n}","import { TeaBlocksError } from './../../../TeaBlocksError';\nimport { ReturnBlock } from \"../../ReturnBlock\";\n\n/**\n * Math division block. Does input[0]/input[1]/input[2]... if all values after input[0] are non zero.\n */\nexport class DivisionBlock extends ReturnBlock {\n    inputs;\n\n    /**\n     * Constructor\n     * @param inputs the inputs.\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.inputs = inputs;\n    }\n\n    /**\n     * Evaluates the expression.\n     * @param varEnv the variable environment\n     */\n    evalBlock(varEnv: Map<string, any>): number {\n        let rVal = Number(this.inputs[0].evalBlock(varEnv));\n        if (this.inputs.length === 1 || rVal === 0 || isNaN(rVal)) {\n            return rVal;\n        }\n\n        this.inputs.slice(1).forEach(inp => {\n            let num = Number(inp.evalBlock(varEnv));\n            if(isNaN(num)) throw new TeaBlocksError('Input is not a number', this.id);\n\n            if (num === 0) {\n                throw new TeaBlocksError('Can\\'t divide by zero.', this.id);\n            }\n            rVal /= num;\n        });\n\n        return rVal;\n    }\n}\n","import { TeaBlocksError } from './../../../TeaBlocksError';\nimport { ReturnBlock } from \"../../ReturnBlock\";\n\n/**\n * Math exponent block. Does input[0]^input[1]^input[2]...\n */\nexport class ExponentBlock extends ReturnBlock {\n    inputs;\n\n    /**\n     * Constructor\n     * @param inputs the left operand\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.inputs = inputs;\n    }\n\n    /**\n     * Evaluates the expression\n     * @param {Map} varEnv variable environment\n     */\n    evalBlock(varEnv: Map<string, any>): number {\n        let firstNum = Number(this.inputs[0].evalBlock(varEnv));\n\n        if (isNaN(firstNum)) throw new TeaBlocksError('Inputs must be numbers', this.id);\n\n        if (this.inputs.length === 1 || firstNum === 1 || firstNum === 0) return firstNum;\n\n        this.inputs.slice(1).forEach(inp => {\n            let pow = Number(inp.evalBlock(varEnv));\n            if (isNaN(pow)) throw new TeaBlocksError('Inputs must be numbers', this.id);\n            if (pow === 0) return 1;\n            firstNum = Math.pow(firstNum, pow);\n        });\n\n        return firstNum;\n    }\n}\n","import { TeaBlocksError } from './../../../TeaBlocksError';\nimport { ReturnBlock } from \"../../ReturnBlock\";\n\n\n/**\n * Math modulo block. Performs inputs[0]%inputs[1]%inputs[2]...\n */\nexport class ModuloBlock extends ReturnBlock {\n    inputs;\n\n    /**\n     * Constructor\n     * @param inputs the operands\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.inputs = inputs;\n    }\n\n    /**\n     * Evaluates the expression\n     * @param varEnv variable environment\n     */\n    evalBlock(varEnv: Map<string, any>): number {\n        let num = Number(this.inputs[0].evalBlock(varEnv));\n\n        if (this.inputs.length === 1) return num;\n        if (isNaN(num)) throw new TeaBlocksError('Inputs Must be Number', this.id);\n\n        this.inputs.slice(1).forEach(inp => {\n            let val = Number(inp.evalBlock(varEnv));\n            if (isNaN(val)) throw new TeaBlocksError('Inputs must be numbers', this.id);\n            num %= val;\n        })\n\n        return num;\n    }\n}\n","import { TeaBlocksError } from './../../../TeaBlocksError';\nimport { ReturnBlock } from \"../../ReturnBlock\";\n\n/**\n * Math multiplication block. Multiplies values together.\n */\nexport class ProductBlock extends ReturnBlock {\n    operands;\n    \n    /**\n     * Constructor\n     * @param  operands operands of multiplication\n     */\n    constructor(id: string, operands: ReturnBlock[]){\n        super(id)\n        this.operands = operands;\n    }\n\n    /**\n     * Evaluates the expression\n     * @param varEnv variable environment\n     * @returns all operands multiplied together (1 if there are no operands)\n     */\n    evalBlock(varEnv: Map<string, any>): number{\n        let ans = 1;\n\n        for(let op of this.operands){\n            let val = Number(op.evalBlock(varEnv));\n            if(isNaN(val)) throw new TeaBlocksError(\"Input not a number\", this.id);\n            if (val === 0) return 0;\n\n            ans *= val;\n        }\n\n        return ans;\n    }    \n}\n","import { TeaBlocksError } from './../../../TeaBlocksError';\nimport { ReturnBlock } from '../../ReturnBlock';\n/**\n * Math subtraction block. Does inputs[0]-inputs[1]-inputs[2]-inputs[3]...\n */\nexport class SubtractBlock extends ReturnBlock {\n    inputs;\n\n    /**\n     * Constructor\n     * @param {ReturnBlock} inputs operands\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.inputs = inputs;\n    }\n\n    /**\n     * Evaluates the expression\n     * @param {Map} varEnv variable environment\n     * @returns left - (right_1 + right_2 + ...)\n     */\n    evalBlock(varEnv: Map<string, any>): number {\n        let ans = Number(this.inputs[0].evalBlock(varEnv));\n        if (isNaN(ans)) throw new TeaBlocksError(\"Input not a number\", this.id);\n\n        for (let op of this.inputs.slice(1)) {\n            let val = Number(op.evalBlock(varEnv));\n            if (isNaN(val)) throw new TeaBlocksError(\"Input not a number\", this.id);\n            ans -= val;\n        }\n        return ans;\n    }\n}\n","import { ReturnBlock } from \"../../ReturnBlock\";\n\n/**\n * Math addition block. Adds left and right values together.\n */\nexport class SumBlock extends ReturnBlock {\n    operands\n\n    /**\n     * Constructor\n     * @param operands \n     */\n    constructor(id: string, operands: ReturnBlock[]) {\n        super(id)\n        this.operands = operands;\n    }\n\n    /**\n     * Evaluates the expression\n     * @param {Map} varEnv variable environment\n     * @returns the sum of all operands.\n     */\n    evalBlock(varEnv: Map<string, any>) {\n        let ans: number | string = '';\n        let stringMode = false;\n\n        for (let op of this.operands) {\n            console.log(op);\n            let val = op.evalBlock(varEnv);\n\n            let numVal = Number(val);\n            stringMode = stringMode || isNaN(numVal);\n\n            if (stringMode) {\n                ans = String(ans) + String(val);\n            } else {\n                ans = Number(ans) + numVal;\n\n            }\n        }\n\n        return ans;\n    }\n}\n","import { ReturnBlock } from \"../ReturnBlock\";\n\n/**\n * Assembly block for ternary statement (condition ? tValue : fValue)\n */\nexport class TernaryBlock extends ReturnBlock {\n\n    condition: ReturnBlock;\n    tValue: ReturnBlock;\n    fValue: ReturnBlock;\n\n    /**\n     * Constructor\n     * @param inputs the inputs. Condition is index 0, true value is index 1, false value is index 2\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.condition = inputs[0];\n        this.tValue = inputs[1];\n        this.fValue = inputs[2];\n    }\n\n    /**\n     * Evaluates the expression.\n     * @param varEnv variable environment\n     * @returns the value of 'condition ? tValue : fValue' expression\n     */\n    evalBlock(varEnv: Map<string, any>): any {\n        let condition = Boolean(this.condition.evalBlock(varEnv));\n\n        let value;\n        if (condition) {\n            value = this.tValue.evalBlock(varEnv);\n        } else {\n            value = this.fValue.evalBlock(varEnv);\n        }\n\n        return value;\n    }\n}","import { TeaBlocksError } from './../../TeaBlocksError';\nimport { ReturnBlock } from '../ReturnBlock';\nimport { VoidBlock } from '../VoidBlock';\n\n/**\n * Block for creating/modifying a variable. Assigns a value to some variable name in variable environment.\n */\nexport class VarAssignBlock extends VoidBlock {\n    varName: string;\n    value: ReturnBlock;\n\n    /**\n     * Constructor (doesn't create the variable itself tho)\n     * \n     * @param varName variable name\n     * @param value value being assigned to the variable (only uses value[0])\n     */\n    constructor(id: string, varName: string, value: ReturnBlock[]) {\n        super(id)\n        this.varName = varName;\n        this.value = value[0];\n    }\n\n    /**\n     * Evaluates the variable assignment\n     * @param varEnv the variable envornment\n     */\n    *evalBlock(varEnv: Map<string, any>) {\n        if (this.varName.includes('$') || this.varName.includes('&')) {\n            throw new TeaBlocksError('Variable name contains illegal character', this.id);\n        }\n        let evalValue = this.value.evalBlock(varEnv);\n        varEnv.set(this.varName, evalValue);\n        yield;\n    }\n}\n","import { InternalCompilerError } from './../../InternalCompilerError';\nimport { ReturnBlock } from \"../ReturnBlock\";\nimport { VarAssignBlock } from \"../variable/VarAssignBlock\";\nimport { VoidBlock } from \"../VoidBlock\";\n\n/**\n * A block to represent a FOR loop (;; style). Creates incrementor variable, executes nodes while \n * the condition holds, incrementing the incrementor variable by some value after each iteration.\n */\nexport class FORBlock extends VoidBlock {\n    counterName;\n    initialValue;\n    condition;\n    incrementValue;\n    nodes;\n    len;\n\n    /**\n     * Constructor\n     * @param counterName name of counter variable\n     * @param initialValue (number) counter initial value (0th index)\n     * @param condition (boolean) condition for running (0th index)\n     * @param incrementValue (number) value by which to increment (positive or negative; 0th index)\n     * @param nodes array of nodes to execute while condition is true. These nodes are roots of trees that\n     * need to be executed conditionaly (loop), hence they must be VoidBlocks.\n     */\n    constructor(id: string, counterName: string,\n        initialValue: ReturnBlock[],\n        condition: ReturnBlock[],\n        incrementValue: ReturnBlock[],\n        nodes: VoidBlock[]) {\n        super(id)\n        this.counterName = counterName;\n        this.initialValue = initialValue[0];\n        this.condition = condition[0];\n        this.incrementValue = incrementValue[0];\n        this.nodes = nodes;\n\n        this.len = 0;\n        for (let b of nodes) {\n            this.len += b.getLength();\n        }\n    }\n\n    *evalBlock(varEnv: Map<string, any>) {\n        // using VarAssignBlock to create/assign the counter variable\n        let countVarAssign = new VarAssignBlock(this.id, this.counterName, [this.initialValue]);\n        countVarAssign.evalBlock(varEnv);\n\n        while (true) {\n            // condition\n            let comp = Boolean(this.condition.evalBlock(varEnv));\n\n            if (!comp) return; // stop if condition false\n\n            // executing nodes\n            for (let node of this.nodes) {\n                if (!(node instanceof VoidBlock)) throw new InternalCompilerError('Loop body must be void');\n\n                let gen = node.evalBlock(varEnv);\n                let status;\n\n                do {\n                    status = gen.next();\n                    yield;\n                } while (!status.done);\n            }\n\n            let incrValue = this.incrementValue.evalBlock(varEnv);\n            varEnv.set(this.counterName, varEnv.get(this.counterName) + incrValue);\n        }\n    }\n\n    getLength() {\n        return this.len;\n    }\n}","import { InternalCompilerError } from './../../InternalCompilerError';\nimport { ReturnBlock } from \"../ReturnBlock\";\nimport { ANDBlock } from \"../returnBlocks/boolean/operators/ANDBlock\";\nimport { VoidBlock } from \"../VoidBlock\";\n\nexport class IFBlock extends VoidBlock {\n    condition; // the condition\n    then; // what is executed if condition is true\n    otherwise; // what is executed otherwise   \n    len; //length\n\n    /**\n     * Constructor for an IF block\n     * @param condition condition block of if statement (boolean). If more than one conditions\n     * are passed in, the AND operation is performed.\n     * @param then block evaluated if condition is true\n     * @param otherwise block evaluated if condition is false\n     */\n    constructor(id: string, condition: ReturnBlock[],\n        then: VoidBlock[],\n        otherwise: VoidBlock[]) {\n        super(id)\n        this.condition = condition;\n        this.then = then;\n        this.otherwise = otherwise;\n\n        let ifLen = 0, elseLen = 0;\n\n        for (let block of then) {\n            ifLen += block.getLength();\n        }\n\n        for(let block of otherwise){\n            elseLen += block.getLength();\n        }\n\n        this.len = Math.max(ifLen, elseLen);\n    }\n\n    /**\n     * Evaluates IF block. If condition is boolean and true, \"then\" block are evaluated, if condition is boolean\n     * and false, \"otherwise\" blocks are executed. If condition is not boolean a TypeError is thrown. \n     * @param varEnv the variable envornment\n     */\n    *evalBlock(varEnv: Map<string, any>) {\n        // evaluating the condition\n        let andInpsConds = this.condition;\n        const andBlock: ANDBlock = new ANDBlock(this.id, andInpsConds);\n        const cond = andBlock.evalBlock(varEnv);\n        const runBlocks = cond ? this.then : this.otherwise;\n\n        for (let block of runBlocks) {\n            if (!(block instanceof VoidBlock)) throw new InternalCompilerError('Loop body must be void');\n\n            let gen = block.evalBlock(varEnv);\n            let status;\n\n            do {\n                status = gen.next();\n                yield;\n            } while (!status.done);\n\n        }\n\n        return;\n    }\n\n    /**\n     * Returns the maximimum minimum execution time for the if statement. (max between if and else sides' minimum\n     * execution length).\n     */\n    getLength(){\n        return this.len;\n    }\n}","import { InternalCompilerError } from './../../InternalCompilerError';\nimport { ReturnBlock } from \"../ReturnBlock\";\nimport { ANDBlock } from \"../returnBlocks/boolean/operators/ANDBlock\";\nimport { VoidBlock } from \"../VoidBlock\";\n\nexport class WHILEBlock extends VoidBlock {\n    conditions;\n    blocks;\n    len: number;\n\n    /**\n     * Constructor\n     * @param conditions the number of iterations (boolean)\n     * @param blocks array of void blocks to execute while condition is true\n     */\n    constructor(id: string, conditions: ReturnBlock[], blocks: VoidBlock[]) {\n        super(id)\n        this.conditions = conditions;\n        this.blocks = blocks;\n\n        this.len = 0;\n        for (let b of blocks) {\n            this.len += b.getLength();\n        }\n    }\n\n\n    /**\n     * If the condition evaluates to true, all blocks are ran. The cycle is repeated untill condition evaluates to false.\n     * @param varEnv the variable envornment\n     */\n    *evalBlock(varEnv: Map<string, any>) {\n        while (true) {\n            let andBlock: ANDBlock = new ANDBlock(this.id, this.conditions);\n            let cond = andBlock.evalBlock(varEnv);\n\n            if (!cond) return;\n\n            for (let block of this.blocks) {\n                if (!(block instanceof VoidBlock)) throw new InternalCompilerError('Loop body must be void');\n\n                let gen = block.evalBlock(varEnv);\n\n                let status;\n                do {\n                    status = gen.next();\n                    yield;\n                } while (!status.done)\n\n            }\n        }\n    }\n\n    /**\n     * Returns the minimum number of steps required to complete a single iteration of the loop.\n     */\n    getLength() {\n        return this.len;\n    }\n}\n","import { ReturnBlock } from \"../ReturnBlock\";\n\n/**\n * A constant value block (essentially a primitive). Takes some value that does not change\n * like a string or a number.\n */\nexport class ConstBlock extends ReturnBlock {\n    value;\n\n    /**\n     * Constructor\n     * @param value value of the constant\n     */\n    constructor(id: string, value: any){\n        super(id)\n        this.value = value;\n    }\n\n    /**\n     * Returns the value of the const block.\n     * @param varEnv variable environment\n     */\n    evalBlock(varEnv: Map<string, any>): any{\n        return this.value;\n    }\n}","import { ConstBlock } from './ConstBlock';\nimport { VarAssignBlock } from './VarAssignBlock';\n\n/**\n * A variable creation block. Creates an empty array.\n */\nexport class ArrayCreateBlock extends VarAssignBlock {\n\n    /**\n     * Constructor\n     * @param id the id of statenode\n     * @param varName name of the array\n     */\n    constructor(id: string, varName: string) {\n        super(id, varName, [new ConstBlock(id, [])]);\n    }\n\n}","import { TeaBlocksError } from './../../TeaBlocksError';\nimport { ReturnBlock } from \"../ReturnBlock\";\n\n/**\n * Block for retrieving a value of an array at a specific index.\n */\nexport class ArrayGetIndex extends ReturnBlock {\n    index: ReturnBlock;\n    arrName: string;\n\n    /**\n     * Constructor\n     * @param id id of state node\n     * @param arrName name of array\n     * @param inputs index is inputs[0]\n     */\n    constructor(id: string, arrName: string, inputs: ReturnBlock[]) {\n        super(id);\n        this.arrName = arrName;\n        this.index = inputs[0];\n    }\n\n\n    /**\n     * Retrieves the value of the array at provided index.\n     * @param varEnv variable environment\n     */\n    evalBlock(varEnv: Map<string, any>) {\n        let arr = varEnv.get(this.arrName);\n        if (arr == null) throw new TeaBlocksError('Array does not exist', this.id);\n\n        let index = Number(this.index.evalBlock(varEnv));\n        if (isNaN(index)) throw new TeaBlocksError('Index is not a number', this.id);\n\n        let val = arr[index];\n\n        if (val == null) throw new TeaBlocksError(`Nothing at index ${index}`, this.id);\n\n        return val;\n    }\n\n\n}","import { TeaBlocksError } from './../../TeaBlocksError';\nimport { ReturnBlock } from \"../ReturnBlock\";\nimport { VoidBlock } from \"../VoidBlock\";\n\nexport class ArraySetIndex extends VoidBlock {\n    arrName: string;\n    index: ReturnBlock;\n    value: ReturnBlock;\n\n    /**\n     * Constructor\n     * @param id the id of state node\n     * @param arrName name of array\n     * @param inputs inputs[0] is the index; inputs[1] is the value\n     */\n    constructor(id: string, arrName: string, inputs: ReturnBlock[]) {\n        super(id);\n        this.arrName = arrName;\n        this.index = inputs[0];\n        this.value = inputs[1];\n    }\n\n\n    /**\n     * Assigns the value to the index of this array. Computes the value being assigned\n     * before the index.\n     * \n     * @param varEnv variable environment\n     */\n    *evalBlock(varEnv: Map<string, any>) {\n        let value = this.value.evalBlock(this.value.evalBlock(varEnv));\n\n        let arr = varEnv.get(this.arrName);\n        if (arr == null) throw new TeaBlocksError('Array does not exist', this.id);\n\n        let index = Number(this.index.evalBlock(varEnv));\n        if (isNaN(index)) throw new TeaBlocksError('Index is not a number', this.id);\n\n        arr[index] = value;\n\n        varEnv.set(this.arrName, arr);\n\n        yield;\n    }\n\n}","import { VoidBlock } from \"../VoidBlock\";\n\n/**\n * Block for deleting a variable from the variable environment\n */\nexport class VarDeleteBlock extends VoidBlock{\n    varName: string;\n\n    /**\n     * Constructor\n     * @param varName variable name\n     */\n    constructor(id: string, varName:string){\n        super(id)\n        this.varName = varName;\n    }\n\n    /**\n     * Deletes varName from variable environment if it exists.\n     * @param varEnv variable environment\n     */\n    *evalBlock(varEnv:Map<string, any>){\n        if(varEnv.has(this.varName)){\n            varEnv.delete(this.varName);\n        }\n        yield;\n    }\n}","import { TeaBlocksError } from './../../TeaBlocksError';\nimport { ReturnBlock } from \"../ReturnBlock\";\n\n/**\n * Block for retrieving the value of a variable from the variable\n * environment based on the variable name.\n */\nexport class VarRetrieveBlock extends ReturnBlock {\n    varName: string;\n\n    /**\n     * Constructor.\n     * @param varName variable name\n     */\n    constructor(id: string, varName: string) {\n        super(id)\n        this.varName = varName;\n    }\n\n    /**\n     * Retrives the value under varName from variable environment if that variable exists.\n     * @param varEnv the variable envornment\n     */\n    evalBlock(varEnv: Map<string, any>): void {\n        if (this.varName.includes('$') || this.varName.includes('&')) {\n            throw new TeaBlocksError('Variable name contains illegal character', this.id);\n        }\n        \n        if (!varEnv.has(this.varName)) {\n            throw new TeaBlocksError(\"Variable \" + this.varName + \" does not exist\", this.id);\n        }\n        return varEnv.get(this.varName);\n    }\n}","import { JoyXStatusBlock, JoyYStatusBlock, ButtonStatusBlock } from \"../assemblyBlocks/inputBlocks\";\nimport { MakeControlElementBlock } from \"../assemblyBlocks/inputBlocks/MakeControlElementBlock\";\nimport { ConsoleLogBlock } from \"../assemblyBlocks/outputBlocks/ConsoleLogBlock\";\nimport { EQBlock, GEQBlock, GTBlock, LTBlock, LEQBlock } from \"../assemblyBlocks/returnBlocks/boolean/comparison\";\nimport { ANDBlock, NOTBlock, ORBlock } from \"../assemblyBlocks/returnBlocks/boolean/operators\";\nimport { DivisionBlock, ExponentBlock, ModuloBlock, ProductBlock, SubtractBlock, SumBlock } from \"../assemblyBlocks/returnBlocks/math\";\nimport { TernaryBlock } from \"../assemblyBlocks/returnBlocks/TernaryBlock\";\nimport { GetXBlock, GetYBlock, MoveBlock, RotateBlock, ScaleBlock } from \"../assemblyBlocks/shape\";\nimport { GetShapeBlock } from \"../assemblyBlocks/shape/GetShapeBlock\";\nimport { MakeShapeBlock } from \"../assemblyBlocks/shape/MakeShapeBlock\";\nimport { WHILEBlock, IFBlock, FORBlock } from \"../assemblyBlocks/specialBlocks\";\nimport { ArrayGetIndex, ArraySetIndex, ConstBlock, VarAssignBlock, VarDeleteBlock, VarRetrieveBlock } from \"../assemblyBlocks/variable\";\nimport { ArrayCreateBlock } from \"../assemblyBlocks/variable/ArrayCreateBlock\";\n\nimport { BlockType } from \"./BlockType\";\n\n// todo organize imports with index.ts files\n\n\n/**\n * Factory for blocks. In JS because this would be really hard to to in TS :/\n * @param {string} id the id of the corresponding state node.\n * @param {BlockType} type type of block being created\n * @param  {...any} inputs vararg inputs\n * @returns {AbstractBlock} the constructed AbstractBlock from type and inputs.\n */\nexport function createAssemblyBlock(id, type, ...inputs) {\n    let a, b, c, d, e; // declared because of scope limitations\n\n    switch (type) {\n        case BlockType.CLB:\n            [a] = inputs;\n            return new ConsoleLogBlock(id, a); // inputs\n        case BlockType.SUM:\n            [a] = inputs;\n            return new SumBlock(id, a); // inputs\n        case BlockType.PROD:\n            [a] = inputs;\n            return new ProductBlock(id, a); //inputs\n        case BlockType.SUBTRACT:\n            [a] = inputs;\n            return new SubtractBlock(id, a); //inputs\n        case BlockType.MOD:\n            [a] = inputs;\n            return new ModuloBlock(id, a);\n        case BlockType.EXP:\n            [a] = inputs;\n            return new ExponentBlock(id, a);\n        case BlockType.DIV:\n            [a] = inputs;\n            return new DivisionBlock(id, a);\n        case BlockType.CONST:\n            [a] = inputs;\n            return new ConstBlock(id, a); // value\n        case BlockType.VAR_ASSIGN:\n            [a, b] = inputs;\n            return new VarAssignBlock(id, a, b); // name, value\n        case BlockType.VAR_RETRIEVE:\n            [a] = inputs;\n            return new VarRetrieveBlock(id, a); // name\n        case BlockType.DELETE:\n            [a] = inputs;\n            return new VarDeleteBlock(id, a); // name\n        case BlockType.TERNARY:\n            [a] = inputs;\n            return new TernaryBlock(id, a); // inputs\n        case BlockType.AND:\n            [a] = inputs;\n            return new ANDBlock(id, a);\n        case BlockType.OR:\n            [a] = inputs;\n            return new ORBlock(id, a);\n        case BlockType.NOT:\n            [a] = inputs;\n            return new NOTBlock(id, a);\n        case BlockType.EQ:\n            [a] = inputs;\n            return new EQBlock(id, a);\n        case BlockType.GEQ:\n            [a] = inputs;\n            return new GEQBlock(id, a);\n        case BlockType.GT:\n            [a] = inputs;\n            return new GTBlock(id, a);\n        case BlockType.LEQ:\n            [a] = inputs;\n            return new LEQBlock(id, a);\n        case BlockType.LT:\n            [a] = inputs;\n            return new LTBlock(id, a);\n        case BlockType.WHILE:\n            [[a, b]] = inputs;\n            return new WHILEBlock(id, a, b); // conditions, blocks\n        case BlockType.IF:\n            console.log(inputs);\n            [[a, b, c]] = inputs;\n            console.log(a);\n            console.log(b);\n            console.log(c);\n            return new IFBlock(id, a, b, c); // condition, then, otherwise\n        case BlockType.FOR:\n            [a, b, c, d, e] = inputs;\n            return new FORBlock(id, a, b, c, d, e); // counter name, init val, condition, incr value, nodes\n        case BlockType.MAKE_SHAPE:\n            [a, b, c] = inputs;\n            return new MakeShapeBlock(id, a, b, c);\n        case BlockType.MOVE_SHAPE:\n            [a] = inputs;\n            return new MoveBlock(id, a);\n        case BlockType.SCALE_SHAPE:\n            [a] = inputs;\n            return new ScaleBlock(id, a);\n        case BlockType.ROTATE_SHAPE:\n            [a] = inputs;\n            return new RotateBlock(id, a);\n        case BlockType.GET_SHAPE:\n            [a] = inputs;\n            return new GetShapeBlock(id, a);\n        case BlockType.JOY_X:\n            [a] = inputs;\n            return new JoyXStatusBlock(id, a); //name\n        case BlockType.JOY_Y:\n            [a] = inputs;\n            return new JoyYStatusBlock(id, a); //name\n        case BlockType.BTN_STATUS:\n            [a] = inputs;\n            return new ButtonStatusBlock(id, a); //name\n        case BlockType.ARR_CREATE:\n            [a] = inputs;\n            return new ArrayCreateBlock(id, a);\n        case BlockType.ARR_SET_IX:\n            [a, b] = inputs;\n            return new ArraySetIndex(id, a, b);\n        case BlockType.ARR_GET_IX:\n            [a, b] = inputs;\n            return new ArrayGetIndex(id, a, b);\n        case BlockType.MAKE_CONTROL_ELEM:\n            [a, b, c] = inputs;\n            return new MakeControlElementBlock(id, a, b, c);\n        case BlockType.GET_X:\n            [a] = inputs;\n            return new GetXBlock(id, a);\n        case BlockType.GET_Y:\n            [a] = inputs;\n            return new GetYBlock(id, a);\n        default:\n            throw new EvalError('Entered BlockType is not yet supported in BlockFactory');\n    }\n}","export * from './CustomNode';\nexport * from './FunctionNode';\nexport * from './GuranteedRoot';\nexport * from './IfNode';\nexport * from './InputNode';\nexport * from './NodeData';\nexport * from './OutputNode';\nexport * from './WhileNode';\n"],"sourceRoot":""}