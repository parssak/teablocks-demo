{"version":3,"sources":["compiler/assemblyBlocks/shape/GetShapeBlock.ts","compiler/assemblyBlocks/shape/MakeShapeBlock.ts","codeBlocks/GuranteedRoot.ts","codeBlocks/InputNode.ts","compiler/assemblyBlocks/AbstractBlock.ts","compiler/assemblyBlocks/inputBlocks/index.ts","compiler/factory/BlockType.ts","compiler/TeaBlocksError.ts","compiler/assemblyBlocks/ReturnBlock.ts","compiler/assemblyBlocks/VoidBlock.ts","compiler/assemblyBlocks/inputBlocks/ControlType.ts","diagram/CustomSchema.ts","ide/NodeBuilder.ts","diagram/DiagramWrapper.js","diagram/UncontrolledDiagram.tsx","ide/DiagramIDE.tsx","compiler/assemblyBlocks/inputBlocks/ButtonStatusBlock.ts","compiler/assemblyBlocks/inputBlocks/JoyXStatusBlock.ts","compiler/assemblyBlocks/inputBlocks/JoyYStatusBlock.ts","diagram/renders/CustomRender.tsx","diagram/renders/IfRender.tsx","diagram/renders/WhileRender.tsx","codeBlocks/FunctionNode.ts","codeBlocks/IfNode.ts","codeBlocks/WhileNode.ts","diagram/renders/RenderHelper.js","diagram/renders/index.ts","compiler/InternalCompilerError.ts","compiler/assemblyBlocks/shape/ShapeColor.ts","compiler/assemblyBlocks/shape/GetXBlock.ts","compiler/assemblyBlocks/shape/GetYBlock.ts","compiler/assemblyBlocks/shape/MoveBlock.ts","compiler/assemblyBlocks/shape/RotateBlock.ts","compiler/assemblyBlocks/shape/ScaleBlock.ts","compiler/assemblyBlocks/shape/ShapeType.ts","compiler/Program.ts","compiler/Compiler.ts","runtime/Canvas.js","runtime/Runtime.tsx","compiler/state/StateNode.ts","ide/Precompiler.ts","serializor/SchemaSerializor.ts","demoContent/Information.js","ide/AppDiagram.tsx","App.tsx","reportWebVitals.ts","index.tsx","compiler/assemblyBlocks/shape/Shape.ts","codeBlocks/OutputNode.ts","compiler/assemblyBlocks/inputBlocks/ControlElement.ts","compiler/assemblyBlocks/inputBlocks/MakeControlElementBlock.ts","compiler/assemblyBlocks/outputBlocks/ConsoleLogBlock.ts","compiler/assemblyBlocks/returnBlocks/boolean/comparison/EQBlock.ts","compiler/assemblyBlocks/returnBlocks/boolean/comparison/GEQBlock.ts","compiler/assemblyBlocks/returnBlocks/boolean/comparison/GTBlock.ts","compiler/assemblyBlocks/returnBlocks/boolean/comparison/LEQBlock.ts","compiler/assemblyBlocks/returnBlocks/boolean/comparison/LTBlock.ts","compiler/assemblyBlocks/returnBlocks/boolean/operators/ANDBlock.ts","compiler/assemblyBlocks/returnBlocks/boolean/operators/NOTBlock.ts","compiler/assemblyBlocks/returnBlocks/boolean/operators/ORBlock.ts","compiler/assemblyBlocks/returnBlocks/math/DivisionBlock.ts","compiler/assemblyBlocks/returnBlocks/math/ExponentBlock.ts","compiler/assemblyBlocks/returnBlocks/math/ModuloBlock.ts","compiler/assemblyBlocks/returnBlocks/math/ProductBlock.ts","compiler/assemblyBlocks/returnBlocks/math/SubtractBlock.ts","compiler/assemblyBlocks/returnBlocks/math/SumBlock.ts","compiler/assemblyBlocks/returnBlocks/TernaryBlock.ts","compiler/assemblyBlocks/variable/VarAssignBlock.ts","compiler/assemblyBlocks/specialBlocks/FORBlock.ts","compiler/assemblyBlocks/specialBlocks/IFBlock.ts","compiler/assemblyBlocks/specialBlocks/WHILEBlock.ts","compiler/assemblyBlocks/variable/ConstBlock.ts","compiler/assemblyBlocks/variable/ArrayCreateBlock.ts","compiler/assemblyBlocks/variable/ArrayGetIndex.ts","compiler/assemblyBlocks/variable/ArraySetIndex.ts","compiler/assemblyBlocks/variable/VarDeleteBlock.ts","compiler/assemblyBlocks/variable/VarRetrieveBlock.ts","compiler/factory/BlockFactory.js","codeBlocks/index.ts"],"names":["GetShapeBlock","id","shapeName","varEnv","internalName","this","has","TeaBlocksError","ReturnBlock","MakeShapeBlock","shapeType","color","inputs","posX","posY","scaleX","scaleY","rot","console","log","String","evalBlock","posx","Number","posy","scalex","scaley","isNaN","set","Shape","VoidBlock","GuranteedRoot","isRoot","InputNode","content","coordinates","numOutputs","blockType","constInputs","data","render","outputs","DiagramIDE","getID","i","port","push","AbstractBlock","BlockType","message","name","Error","voidBlock","ControlType","FIRST_COORDINATE","CustomSchema","nodes","links","length","NodeBuilder","schemaId","parentSchemaId","getIDE","validatedSchemas","coors","get","getNextCoordinates","type","nextCoordinates","centralizeCoordinates","SUM","addFunctionNode","PROD","SUBTRACT","DIV","EQ","LT","GT","LEQ","GEQ","AND","OR","NOT","TERNARY","MOD","EXP","GET_X","GET_Y","error","CONST","cstVal","prompt","addInputNode","VAR_RETRIEVE","varName","GET_SHAPE","shapeget","JOY_X","joyxname","JOY_Y","joyyname","ARR_GET_IX","arrName","CLB","addOutputNode","VAR_ASSIGN","VAR_DELETE","varDeleteName","MAKE_SHAPE","ShapeType","RECT","ShapeColor","BLUE","ROTATE_SHAPE","MOVE_SHAPE","SCALE_SHAPE","ARR_CREATE","arrMake","ARR_SET_IX","MAKE_CONTROL_ELEM","elemType","JOYSTICK","elemName","IF","nextIf","IfNode","parentSchema","inputNames","problematic","IfRender","schemaMethods","addNode","WHILE","nextWhile","WhileNode","WhileRender","constVal","numOfOutputs","outputNames","nextNode","CustomRender","numOfInputs","OutputNode","FunctionNode","DiagramWrapper","props","schema","onChange","UncontrolledDiagram","initialSchema","useSchema","removeNode","deleteNodeFromSchema","nodeToRemove","find","node","useState","nodeBuilder","Function","makeCallback","setMakeCallback","scheduleMakeInput","callback","coor","makeInput","scheduleMakeOutput","makeOutput","scheduleMakeFunction","makeFunction","scheduleMakeSpecial","makeSpecial","useEffect","addSchema","className","onClick","e","pageX","pageY","clickMakeNode","undefined","icon","ideId","displaySchemaId","Map","globalNextId","toRender","ReactDOM","document","getElementById","leRoot","unmountComponentAtNode","renderDiagram","methods","redrawDiagram","schemas","startID","nodeId","forEach","Array","from","values","foundNode","instance","ButtonStatusBlock","buttonName","val","Boolean","JoyXStatusBlock","joyName","vName","x","JoyYStatusBlock","y","inpDivs","RenderHelper","makeInputDivs","outDivs","makeOutputDivs","size","deleteNode","setDisplaySchemaId","numInputs","ix","React","cloneElement","key","InternalCompilerError","GetXBlock","shape","GetYBlock","MoveBlock","RotateBlock","ScaleBlock","interuptSignal","Program","subroutines","triggerDict","triggeredIndexes","taskQueue","errorNotify","Set","ixArr","add","trigName","t","sub","buildTaskQueue","getLength","scheduleNextTask","filter","task","gen","stopCleanup","status","s","count","next","done","err","window","requestAnimationFrame","_","eventLoop","nextTask","shift","aaa","trees","compileTree","a","hasBeenCompiled","EvalError","isInput","compiledNode","createAssemblyBlock","trigSet","isTriggered","thisNodeChildren","children","map","childArr","child","compiledChild","trig","subroutine","Canvas","draw","rest","canvasRef","useRef","animationFrameId","canvas","current","context","getContext","frameCount","style","width","height","offsetWidth","offsetHeight","cancelAnimationFrame","ref","Runtime","program","inputStorage","state","bind","setup","inputVal","inputName","started","newJoy","trigger","value","joystickName","substring","joystick","position","left","bottom","baseColor","stickColor","move","handleMove","stop","handleStop","start","handleStart","setState","prevState","ctx","clearRect","moveThing","constructor","addShape","newVals","element","fillStyle","addRect","CIRCLE","TRIANGLE","HEART","STAR","w","h","beginPath","rect","fill","comp","Component","StateNode","BTN_STATUS","RECURSIVE_MAX_DEPTH","sortRoots","roots","sort","b","groups","groupTracker","root","xVal","range","group","flat","Precompiler","precompile","mainSchema","ms","getRoots","sorte","index","arr","indexOf","precompRoot","depth","ifSchema","ifSchemaRoots","ifChildren","innerRoot","compChild","elseSchema","elseSchemaRoots","elseChildren","condition","getChildren","compiledCondition","leIf","whileSchema","whileSchemaRoots","compiledWhile","compNest","myChildren","compiledChildren","includes","portIds","childrenOutputPorts","link","input","output","portId","precompiledStuff","SchemaSerializor","save","ids","nodeIDStart","JSON","stringify","json","parse","valSchemas","Information","loadBouncy","loadJoystick","emptyProgram","canShowPopup","AppDiagram","setProgram","popOpen","setPopOpen","build","unflagNodes","precomp","compile","then","prog","catch","flagNodes","stringified","bouncyProgram","deserialize","nID","loadSchemas","joystickProgram","togglePopup","rtElem","run","runProg","App","reportWebVitals","onPerfEntry","getCLS","getFID","getFCP","getLCP","getTTFB","StrictMode","ControlElement","displayName","MakeControlElementBlock","elem","ConsoleLogBlock","inp","EQBlock","leftSide","rightSide","GEQBlock","GTBlock","LEQBlock","LTBlock","ANDBlock","NOTBlock","bool","ORBlock","DivisionBlock","rVal","slice","num","ExponentBlock","firstNum","pow","Math","ModuloBlock","ProductBlock","operands","ans","op","SubtractBlock","SumBlock","stringMode","numVal","TernaryBlock","tValue","fValue","VarAssignBlock","evalValue","FORBlock","counterName","initialValue","incrementValue","len","incrValue","IFBlock","otherwise","ifLen","elseLen","max","andInpsConds","andBlock","cond","runBlocks","block","WHILEBlock","conditions","blocks","ConstBlock","ArrayCreateBlock","ArrayGetIndex","ArraySetIndex","VarDeleteBlock","delete","VarRetrieveBlock","c","d","DELETE","FOR"],"mappings":"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","file":"static/js/main.4c71490f.chunk.js","sourcesContent":["import { TeaBlocksError } from './../../TeaBlocksError';\nimport { ReturnBlock } from \"../ReturnBlock\";\n\n/**\n * Takes in the shape name (display name), checks if the name exists, and returns the internal name of the shape.\n */\nexport class GetShapeBlock extends ReturnBlock {\n    shapeName: string;\n\n    /**\n     * Constructor\n     * @param shapeName the name of the shape being retrieved\n     */\n    constructor(id: string, shapeName: string) {\n        super(id)\n        this.shapeName = shapeName;\n    }\n\n    /**\n     * Retrieves the internal shape name. Throws error if it does not exist.\n     * @param varEnv variable environment\n     */\n    evalBlock(varEnv: Map<string, any>): string {\n        let internalName = '$' + this.shapeName;\n        if (varEnv.has(internalName)) return internalName;\n        throw new TeaBlocksError(`Shape ${this.shapeName} does not exist!`, this.id);\n    }\n\n}","import { TeaBlocksError } from './../../TeaBlocksError';\nimport { ShapeColor } from './ShapeColor';\nimport { ReturnBlock } from \"../ReturnBlock\";\nimport { VoidBlock } from \"../VoidBlock\";\nimport { Shape } from \"./Shape\";\nimport { ShapeType } from \"./ShapeType\";\n\n/**\n * Creates variable parameters for some shape\n */\nexport class MakeShapeBlock extends VoidBlock {\n    shapeName: ReturnBlock;\n    color: ShapeColor;\n    shapeType: ShapeType;\n    posX: ReturnBlock;\n    posY: ReturnBlock;\n    scaleX: ReturnBlock;\n    scaleY: ReturnBlock;\n    rot: ReturnBlock;\n\n    /**\n     * Constructor\n     * \n     * @param id the id\n     * @param shapeType the type of the shape\n     * @param color the color of the shape.\n     * @param inputs inputs\n     */\n    constructor(id:string, shapeType: ShapeType, color: ShapeColor,\n        inputs: ReturnBlock[]) {\n        super(id);\n        this.shapeType = shapeType;\n        this.color = color;\n\n        console.log(inputs);\n\n        this.shapeName = inputs[0];\n        this.posX = inputs[1];\n        this.posY = inputs[2];\n        this.scaleX = inputs[3];\n        this.scaleY = inputs[4];\n        this.rot = inputs[5];\n    }\n\n    /**\n     * Creates variable array for new shape\n     * @param varEnv variable environment\n     */\n    *evalBlock(varEnv: Map<string, any>) {\n        let shapeName = String(this.shapeName.evalBlock(varEnv));\n        let posx = Number(this.posX.evalBlock(varEnv));\n        let posy = Number(this.posY.evalBlock(varEnv));\n        let scalex = Number(this.scaleX.evalBlock(varEnv));\n        let scaley = Number(this.scaleY.evalBlock(varEnv));\n        let rot = Number(this.rot.evalBlock(varEnv));\n\n        console.log(shapeName);\n        console.log(posx);\n        console.log(posy);\n        console.log(scalex);\n        console.log(scaley);\n        console.log(rot);\n\n        if (isNaN(posx) ||\n            isNaN(posy) ||\n            isNaN(scalex) ||\n            isNaN(scaley) ||\n            isNaN(rot)) {\n            throw new TeaBlocksError(\"Shape input not a number\", this.id);\n        }\n\n        varEnv.set('$' + shapeName, new Shape(shapeName, this.shapeType, this.color, posx, posy, scalex, scaley, rot));\n        yield;\n    }\n}","\n/**\n * A class for a guranteed root node.\n */\nexport class GuranteedRoot{\n    isRoot: boolean;\n    constructor(){\n        this.isRoot = true;\n    }\n}","import { NodeData } from './NodeData';\nimport { BlockType } from './../compiler/factory/BlockType';\nimport { Node, NodeCoordinates, Port } from 'beautiful-react-diagrams/@types/DiagramSchema';\nimport { ElementType, ReactNode } from 'react';\nimport { CustomNode } from './CustomNode';\nimport DiagramIDE from '../ide/DiagramIDE';\n\n\nexport class InputNode implements CustomNode {\n    id: string;\n    coordinates: NodeCoordinates;\n    content: ReactNode;\n    outputs: Port[];\n    data: NodeData;\n    render: (\n        props: Omit<Node<any>, 'coordinates'>\n    ) => ElementType | ReactNode;\n    blockType: BlockType;\n    constInputs: any[];\n\n    /**\n     * \n     * @param content content of this node\n     * @param coordinates inital coordinates of the node\n     * @param numOutputs the number of output ports this node should have\n     * @param blockType the type of the assembly block created (for phasing out assConstructor)\n     * @param constInputs constant inputs that assembly block takes.\n     * @param data data of the node (any object; should contain assConstructor)\n     * @param render renderer used to render\n     * ! ^ data is kinda weird. need to figure out how to replace it with more concrete/safe types.\n     */\n    constructor(content: ReactNode,\n        coordinates: NodeCoordinates,\n        numOutputs: number,\n        blockType: BlockType,\n        constInputs: any[],\n        data: NodeData,\n        render: (props: Omit<Node<any>, 'coordinates'>) => ElementType | ReactNode) {\n        this.id = DiagramIDE.getID()\n        this.coordinates = coordinates;\n        this.content = content;\n        this.data = data;\n        this.render = render;\n\n        this.blockType = blockType;\n        this.constInputs = constInputs;\n\n        console.log('Inputs id: ' + this.id);\n\n        this.outputs = [];\n        for (let i = 0; i < numOutputs; i++) {\n            let port: Port = { id: this.id + '-output-' + i };\n            this.outputs.push(port);\n        }\n    }\n\n\n\n}","/**\n * Abstract assembly block class.\n */\nexport abstract class AbstractBlock{\n    id: string;\n\n    constructor(id: string){\n        this.id = id;\n    }\n\n\n    /**\n     * Function to evaluate the contents (including children) of this abstract block\n     * @param varEnv Variable Environment\n     */\n    abstract evalBlock(varEnv: Map<string, any>): any;\n}","export * from './ButtonStatusBlock';\nexport * from './JoyXStatusBlock';\nexport * from './JoyYStatusBlock';\nexport * from './AssemblyJoystick';\n","/**\n * An enum to specify the type of block being deserialized\n */\nexport enum BlockType{\n    CLB, // console log block\n    CONST,\n    EQ,\n    GEQ,\n    GT,\n    LEQ,\n    LT,\n    AND,\n    NOT,\n    OR,\n    DIV,\n    SUM,\n    SUBTRACT,\n    EXP,\n    MOD,\n    PROD,\n    MAKE_SHAPE,\n    MOVE_SHAPE,\n    ROTATE_SHAPE,\n    SCALE_SHAPE,\n    GET_SHAPE,\n    FOR,\n    IF,\n    WHILE,\n    TERNARY,\n    VAR_ASSIGN,\n    VAR_DELETE,\n    VAR_RETRIEVE,\n    NEST,\n    JOY_X,\n    JOY_Y,\n    BTN_STATUS,\n    ARR_CREATE,\n    ARR_SET_IX,\n    ARR_GET_IX,\n    MAKE_CONTROL_ELEM,\n    GET_X,\n    GET_Y,\n}","/**\n * A custom error for TeaBlocks runtime error that contain information about where (node)\n * the error originates from. These errors are created either by user error or\n * by bugs in the code :/\n */\nexport class TeaBlocksError extends Error {\n    id: string;\n\n    /**\n     * Constructor.\n     * @param message error message (kid friendly text)\n     * @param id the id of the assembly block/state node/diagram node that threw this error.\n     */\n    constructor(message: string, id: string) {\n        super(message);\n        this.id = id;\n        this.name = 'TeaBlocksError';\n    }\n}","import { AbstractBlock } from \"./AbstractBlock\";\n/**\n * An abstract class for assembly blocks that return \n */\nexport abstract class ReturnBlock extends AbstractBlock{\n    abstract evalBlock(varEnv: Map<string, any>): any;\n}","import { AbstractBlock } from \"./AbstractBlock\";\n\nexport abstract class VoidBlock extends AbstractBlock{\n    voidBlock: boolean = true;\n\n    abstract evalBlock(varEnv: Map<string,any>): IterableIterator<void>;\n\n    /**\n     * How many execution steps a void block takes to execute at most. The default value is 1.\n     * This method would be overriden by more complex void blocks such as loops and if statements\n     * that take more than one step to complete.\n     */\n    getLength(): number{\n        return 1;\n    }\n}","/**\n * The type of UI controll.\n */\nexport enum ControlType {\n    JOYSTICK='joy',\n    BUTTON='btn',\n}","import { NodeData } from './../codeBlocks/NodeData';\nimport { CustomNode } from './../codeBlocks/CustomNode';\nimport { DiagramSchema, Link } from \"beautiful-react-diagrams/@types/DiagramSchema\";\n\nconst FIRST_COORDINATE: [number, number] = [150, 60]; // coordinate of the first node\nconst NEXT_X: number = 150; // value to add to last x coordinate for the next node\n\nexport class CustomSchema implements DiagramSchema<NodeData>{\n    nodes: CustomNode[];\n    links: Link[];\n\n    constructor() {\n        this.nodes = [];\n        this.links = [];\n    }\n\n    /**\n     * Returns the coordinates for the next node. If no node exists it will return FIRST_COORIDNATE If a node\n     * exists, it will return NEXT_X more x value of the last node in schema. \n     */\n    getNextCoordinates(): [number, number] {\n        if (this.nodes == null || this.nodes.length === 0) {\n            return FIRST_COORDINATE;\n        }\n        return [\n            this.nodes[this.nodes.length - 1].coordinates[0] + NEXT_X,\n            this.nodes[this.nodes.length - 1].coordinates[1]\n        ]\n    }\n\n    \n\n}","import { ControlType } from './../compiler/assemblyBlocks/inputBlocks/ControlType';\nimport { BlockType } from '../compiler/factory';\nimport { CustomRender, IfRender, WhileRender } from '../diagram/renders';\nimport { ShapeType, ShapeColor } from '../compiler/assemblyBlocks/shape';\nimport { FunctionNode, OutputNode, InputNode, IfNode, WhileNode } from '../codeBlocks';\nimport DiagramIDE from './DiagramIDE';\n\n/**\n * A class that adds nodes to the schema. (For cleanness)\n */\nexport class NodeBuilder {\n    parentSchemaId;\n\n    /**\n     * Constructor\n     * @param addNode function to add node to schema.\n     * @param schemaId the id of the parent schema.\n     */\n    constructor(schemaId: string) {\n        this.parentSchemaId = schemaId\n    }\n\n    private centralizeCoordinates(coordinates: [number, number]): [number, number] {\n        return [coordinates[0] - 100, coordinates[1] - 100];\n    }\n\n    private nextCoordinates(): [number, number] {\n        if (!DiagramIDE.getIDE().validatedSchemas.has(this.parentSchemaId)) throw Error('Not initalized!');\n        let coors = DiagramIDE.getIDE().validatedSchemas.get(this.parentSchemaId)?.getNextCoordinates();\n        return coors ? coors : [0, 0];\n    }\n\n    /**\n     * Creates a block with this block into the diagram.\n     * @param type type of block created\n     * @param coordinates the coordinates where to make\n     */\n    makeFunction(type: BlockType, coordinates: [number, number] = this.nextCoordinates()) {\n        coordinates = this.centralizeCoordinates(coordinates);\n\n        switch (type) {\n            case BlockType.SUM:\n                this.addFunctionNode('Adder', type, [], 2, 1, ['In', 'In'], ['Out'], coordinates);\n                break;\n            case BlockType.PROD:\n                this.addFunctionNode('Multiply', type, [], 2, 1, ['In', 'In'], ['Out'], coordinates);\n                break;\n            case BlockType.SUBTRACT:\n                this.addFunctionNode('Subtract', type, [], 2, 1, ['In', 'In'], ['Out'], coordinates);\n                break;\n            case BlockType.DIV:\n                this.addFunctionNode('Divide', type, [], 2, 1, ['In', 'In'], ['Out'], coordinates);\n                break;\n            case BlockType.EQ:\n                this.addFunctionNode('==', type, [], 2, 1, ['Left', 'Right'], ['Out'], coordinates);\n                break;\n            case BlockType.LT:\n                this.addFunctionNode('<', type, [], 2, 1, ['Left', 'Right'], ['Out'], coordinates);\n                break;\n            case BlockType.GT:\n                this.addFunctionNode('>', type, [], 2, 1, ['Left', 'Right'], ['Out'], coordinates);\n                break;\n            case BlockType.LEQ:\n                this.addFunctionNode('<=', type, [], 2, 1, ['Left', 'Right'], ['Out'], coordinates);\n                break;\n            case BlockType.GEQ:\n                this.addFunctionNode('>=', type, [], 2, 1, ['Left', 'Right'], ['Out'], coordinates);\n                break;\n            case BlockType.AND:\n                this.addFunctionNode('AND', type, [], 2, 1, ['Left', 'Right'], ['Out'], coordinates);\n                break;\n            case BlockType.OR:\n                this.addFunctionNode('OR', type, [], 2, 1, ['Left', 'Right'], ['Out'], coordinates);\n                break;\n            case BlockType.NOT:\n                this.addFunctionNode('NOT', type, [], 1, 1, ['in'], ['Out'], coordinates);\n                break;\n            case BlockType.TERNARY:\n                this.addFunctionNode('Ternary', type, [], 3, 1, ['If', 'Then', 'Else'], ['Out'], coordinates);\n                break;\n            case BlockType.MOD:\n                this.addFunctionNode('Modulo %', type, [], 2, 1, ['In', 'In'], ['Out'], coordinates);\n                break;\n            case BlockType.EXP:\n                this.addFunctionNode('Exponent', type, [], 2, 1, ['In', 'In'], ['Out'], coordinates);\n                break;\n            case BlockType.GET_X:\n                this.addFunctionNode('Get X', type, [], 1, 1, ['Shape'], ['X'], coordinates);\n                break;\n            case BlockType.GET_Y:\n                this.addFunctionNode('Get Y', type, [], 1, 1, ['Shape'], ['Y'], coordinates);\n                break;\n            default:\n                console.error('This type is not supported by makeFunction')\n        }\n\n    }\n\n    /**\n     * Creates a block with this block type.\n     * @param {BlockType} type type of block created\n     * @param coordinates the coordinates where to make\n     */\n    makeInput(type: BlockType, coordinates: [number, number] = this.nextCoordinates()) {\n        coordinates = this.centralizeCoordinates(coordinates);\n\n        switch (type) {\n            case BlockType.CONST:\n                let cstVal = prompt('What is the value?', '0');\n                this.addInputNode(`Constant: ${cstVal}`, type, [cstVal], 1, ['Value'], coordinates);\n                break;\n            case BlockType.VAR_RETRIEVE:\n                let varName = prompt('What is the name of the variable?');\n                this.addInputNode(`Get ${varName}`, type, [varName], 1, ['Value'], coordinates);\n                break;\n            case BlockType.GET_SHAPE:\n                let shapeget = prompt('What shape name?');\n                this.addInputNode(`Get ${shapeget}`, type, [shapeget], 1, ['Shape'], coordinates);\n                break;\n            case BlockType.JOY_X:\n                let joyxname = prompt('What joystick name?', 'joystick');\n                this.addInputNode(`Get ${joyxname} X`, type, [joyxname], 1, ['X'], coordinates);\n                break;\n            case BlockType.JOY_Y:\n                let joyyname = prompt('What joystick name?', 'joystick');\n                this.addInputNode(`Get ${joyyname} Y`, type, [joyyname], 1, ['Y'], coordinates);\n                break;\n            case BlockType.ARR_GET_IX:\n                let arrName = prompt('What is the array name');\n                this.addInputNode(`Get ${arrName}`, type, [arrName], 1, ['Value'], coordinates);\n                break;\n            default:\n                console.error('This type is not supported by makeInput')\n                return;\n        }\n    }\n\n    /**\n     * Creates an output block.\n     * @param {BlockType} type type of block\n     * @param coordinates the coordinates\n     */\n    makeOutput(type: BlockType, coordinates: [number, number] = this.nextCoordinates()) {\n        coordinates = this.centralizeCoordinates(coordinates);\n\n        switch (type) {\n            case BlockType.CLB:\n                this.addOutputNode('Console', type, [], 1, ['Value'], coordinates);\n                break;\n            case BlockType.VAR_ASSIGN:\n                let varName = prompt('Pick a variable name');\n                this.addOutputNode(`Assign ${varName}`, type, [varName], 1, ['Value'], coordinates);\n                break;\n            case BlockType.VAR_DELETE:\n                let varDeleteName = prompt('Pick a variable name to delete');\n                this.addOutputNode(`Delete ${varDeleteName}`, type, [varDeleteName], 0, [], coordinates);\n                break;\n            case BlockType.MAKE_SHAPE:\n                let shapeType = prompt('Pick a type!', ShapeType.RECT);\n                let color = prompt('Pick a color (rgb value)', ShapeColor.BLUE);\n                this.addOutputNode(`Make ${shapeType}`, type, [shapeType, color], 6, ['Name', 'X', 'Y', 'Stretch-X', 'Stretch-Y', 'Rotation'], coordinates);\n                break;\n            case BlockType.ROTATE_SHAPE:\n                this.addOutputNode('Rotate', type, [], 2, ['Shape', 'Rotation'], coordinates);\n                break;\n            case BlockType.MOVE_SHAPE:\n                this.addOutputNode('Move', type, [], 3, ['Shape', 'X', 'Y'], coordinates);\n                break;\n            case BlockType.SCALE_SHAPE:\n                this.addOutputNode('Stretch', type, [], 3, ['Shape', 'X', 'Y'], coordinates);\n                break;\n            case BlockType.ARR_CREATE:\n                let arrMake = prompt('What is the name of array?');\n                this.addOutputNode(`Create ${arrMake}`, type, [arrMake], 0, [], coordinates);\n                break;\n            case BlockType.ARR_SET_IX:\n                let arrName = prompt('What is the name of array?');\n                this.addOutputNode(`Set ${arrName}`, type, [arrName], 2, ['Index', 'Value'], coordinates);\n                break;\n            case BlockType.MAKE_CONTROL_ELEM:\n                let elemType = prompt('Pick element type', ControlType.JOYSTICK);\n                let elemName = prompt('Pick element name', 'joystick');\n                this.addOutputNode(`Make ${elemName}`, type, [elemType, elemName], 2, ['X', 'Y'], coordinates);\n                break;\n            default:\n                console.error('This node is not supported by makeOutput');\n                return;\n        }\n    }\n\n    makeSpecial(type: BlockType, coordinates: [number, number] = this.nextCoordinates()) {\n        coordinates = this.centralizeCoordinates(coordinates);\n\n        switch (type) {\n            case BlockType.IF:\n                const nextIf = new IfNode('IF',\n                    coordinates,\n                    [],\n                    {\n                        parentSchema: this.parentSchemaId,\n                        inputNames: ['Condition'],\n                        problematic: false,\n                    },\n                    IfRender);\n\n                DiagramIDE.getIDE().schemaMethods.get(this.parentSchemaId)?.addNode(nextIf);\n\n                break;\n            case BlockType.WHILE:\n                const nextWhile = new WhileNode('WHILE',\n                    coordinates,\n                    [],\n                    {\n                        parentSchema: this.parentSchemaId,\n                        inputNames: ['Condition'],\n                        problematic: false,\n                    },\n                    WhileRender);\n                DiagramIDE.getIDE().schemaMethods.get(this.parentSchemaId)?.addNode(nextWhile);\n                break\n            default:\n                console.error('This node is not supported by makeSpecial')\n                return;\n        }\n    }\n\n    /**\n     * Adds an input node.\n     * @param {string} name name of the node\n     * @param {BlockType} type type of block\n     * @param {any[]} constVal constant values\n     * @param {number} numOfOutputs the number of outputs of this nod\n     * @param {string[]} outputNames the names of each output of this node\n     * @param coordinates the coordinates of this node. \n     */\n    addInputNode(name: {} | null | undefined, type: BlockType, constVal: any[], numOfOutputs: number, outputNames: string[] = [], coordinates: [number, number]) {\n        const nextNode = new InputNode(name,\n            coordinates,\n            numOfOutputs,\n            type,\n            constVal,\n            { parentSchema: this.parentSchemaId, outputNames: outputNames, problematic: false },\n            CustomRender);\n\n        DiagramIDE.getIDE().schemaMethods.get(this.parentSchemaId)?.addNode(nextNode);\n    }\n\n    /**\n     * Makes an output node\n     * @param {string} name name\n     * @param {BlockType} type type of block this is\n     * @param {any[]} constVal constant values\n     * @param {number} numOfInputs number of inputs\n     * @param {string[]} inputNames the names of each input to this node\n     * @param coordinates the coordinates of the node\n     */\n    addOutputNode(name: string, type: BlockType, constVal: any[], numOfInputs: number, inputNames: string[], coordinates: [number, number]) {\n        const nextNode = new OutputNode(name,\n            coordinates,\n            numOfInputs,\n            type,\n            constVal,\n            { parentSchema: this.parentSchemaId, inputNames: inputNames, problematic: false },\n            CustomRender);\n\n        DiagramIDE.getIDE().schemaMethods.get(this.parentSchemaId)?.addNode(nextNode);\n\n    }\n\n    /**\n     * Makes a function node\n     * @param {string} name name of the node\n     * @param {BlockType} type type of block\n     * @param {any[]} constVal constant values\n     * @param {number} numOfInputs number of inputs\n     * @param {number} numOfOutputs number of outputs\n     * @param {string[]} inputNames the names of each input to this node\n     * @param {string[]} outputNames the names of each output of this node\n     */\n    addFunctionNode(name: string, type: BlockType, constVal: any[], numOfInputs: number, numOfOutputs: number, inputNames: string[], outputNames: string[], coordinates: [number, number]) {\n        const nextNode = new FunctionNode(name,\n            coordinates,\n            numOfInputs,\n            numOfOutputs,\n            type,\n            constVal,\n            { parentSchema: this.parentSchemaId, inputNames: inputNames, outputNames: outputNames, problematic: false },\n            CustomRender);\n\n        DiagramIDE.getIDE().schemaMethods.get(this.parentSchemaId)?.addNode(nextNode);\n    }\n\n\n\n}","import Diagram from \"beautiful-react-diagrams\";\nimport '../styles/UncontrolledDiagram.scss';\n\n\n/**\n * A shitty wrapper for a shitty library.\n * @param {any} props the props if u know what i mean :/ \n * @return {JSX.Element}\n */\nexport default function DiagramWrapper(props) {\n    return (\n        <Diagram schema={props.schema} onChange={props.onChange} />\n    );\n}","import '../styles/UncontrolledDiagram.scss';\nimport { useSchema } from 'beautiful-react-diagrams';\nimport { useEffect, useState } from 'react';\nimport { Button } from 'beautiful-react-ui';\nimport { CustomSchema } from './CustomSchema';\nimport { NodeBuilder } from '../ide/NodeBuilder';\nimport { BlockType } from '../compiler/factory';\nimport DiagramIDE from '../ide/DiagramIDE';\nimport DiagramWrapper from './DiagramWrapper';\n\ninterface Props {\n    schemaId: string;\n}\n\nexport default function UncontrolledDiagram(props: Props) {\n\n    let initialSchema = DiagramIDE.getIDE().validatedSchemas.get(props.schemaId);\n\n    const [schema, { onChange, addNode, removeNode }] = useSchema(initialSchema ? initialSchema : new CustomSchema());\n\n    const deleteNodeFromSchema = (id: string) => {\n        const nodeToRemove = schema.nodes.find(node => node.id === id);\n\n        if (nodeToRemove) {\n            removeNode(nodeToRemove);\n        }\n    };\n\n    const [nodeBuilder] = useState(new NodeBuilder(props.schemaId));\n    const [makeCallback, setMakeCallback] = useState(Function);\n\n\n    useEffect(() => {\n        DiagramIDE.getIDE().addSchema(props.schemaId, schema as CustomSchema, {\n            deleteNodeFromSchema: deleteNodeFromSchema,\n            onChange: onChange,\n            addNode: addNode\n        });\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [schema]);\n\n\n    function clickMakeNode(e: React.MouseEvent): void {\n        if (makeCallback == null) {\n            return;\n        }\n\n        makeCallback([e.pageX, e.pageY]);\n        setMakeCallback(() => { });\n    }\n\n    function scheduleMakeInput(type: BlockType) {\n        const callback = (coor: [number, number]) => {\n            nodeBuilder.makeInput(type, coor);\n        }\n        setMakeCallback(() => callback);\n    }\n\n    function scheduleMakeOutput(type: BlockType) {\n        const callback = (coor: [number, number]) => {\n            nodeBuilder.makeOutput(type, coor);\n        }\n        setMakeCallback(() => callback);\n    }\n\n    function scheduleMakeFunction(type: BlockType) {\n        const callback = (coor: [number, number]) => {\n            nodeBuilder.makeFunction(type, coor);\n        }\n        setMakeCallback(() => callback);\n    }\n\n    function scheduleMakeSpecial(type: BlockType) {\n        const callback = (coor: [number, number]) => {\n            nodeBuilder.makeSpecial(type, coor);\n        }\n        setMakeCallback(() => callback);\n    }\n\n\n    return (\n        <div className=\"diagram-section\" >\n            \n            <div className=\"diagram-display-area\" onClick={e => clickMakeNode(e)}>\n                {makeCallback !== undefined && makeCallback.name !== \"anonymous\" && <div className=\"create-node-prompt\">\n                    <div className=\"wrapper\">\n                        <h2>Click anywhere on canvas to create node</h2>\n                    </div>\n                </div>}  \n                \n                <DiagramWrapper schema={schema} onChange={onChange} />\n                \n            </div>\n            <div className={'sidebar'}>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeInput(BlockType.CONST)}>Constant</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeOutput(BlockType.VAR_ASSIGN)}>Variable Assign</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeInput(BlockType.VAR_RETRIEVE)}>Variable Get</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeOutput(BlockType.VAR_DELETE)}>Variable Delete</Button>\n                <hr />\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeOutput(BlockType.ARR_CREATE)}>Create Array</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeOutput(BlockType.ARR_SET_IX)}>Array Set Index</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeInput(BlockType.ARR_GET_IX)}>Array Get Index</Button>\n                <hr />\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.SUM)}>Adder</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.SUBTRACT)}>Subtract</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.PROD)}>Multiply</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.DIV)}>Divide</Button>\n                <hr />\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeOutput(BlockType.MAKE_CONTROL_ELEM)}>Create Control</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeInput(BlockType.JOY_X)}>Joystick X</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeInput(BlockType.JOY_Y)}>Joystick Y</Button>\n                <hr />\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeOutput(BlockType.MAKE_SHAPE)}>Shape</Button>\n                <Button color=\"primary\" icon=\"arrow-up\" onClick={() => scheduleMakeInput(BlockType.GET_SHAPE)}>Get Shape</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeOutput(BlockType.MOVE_SHAPE)}>Move Shape</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeOutput(BlockType.ROTATE_SHAPE)}>Rotate Shape</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeOutput(BlockType.SCALE_SHAPE)}>Stretch Shape</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.GET_X)}>Get X</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.GET_Y)}>Get Y</Button>\n\n                <hr />\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.GEQ)}>&gt;=</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.LEQ)}>&lt;=</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.LT)}>&lt;</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.GT)}>&gt;</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.EQ)}>==</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.AND)}>AND</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.OR)}>OR</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.NOT)}>NOT</Button>\n                <hr />\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeFunction(BlockType.TERNARY)}>if then else</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeSpecial(BlockType.IF)}>IF</Button>\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeSpecial(BlockType.WHILE)}>WHILE</Button>\n\n\n                <hr />\n                <Button color=\"primary\" icon=\"plus\" onClick={() => scheduleMakeOutput(BlockType.CLB)}>Print</Button>\n            </div>\n        </div>\n    );\n};","import ReactDOM from 'react-dom';\nimport { CustomSchema } from '../diagram/CustomSchema';\nimport UncontrolledDiagram from '../diagram/UncontrolledDiagram';\n\nconst IDE_ID = 'ide';\n\n/**\n * An interface for a bundle of schema operations.\n */\ninterface SchemaMethodBundle {\n    deleteNodeFromSchema: Function;\n    onChange: Function;\n    addNode: Function;\n}\n\n/**\n * Manually renderes diagram component using ReactDOM. This is a singleton class;\n * use getIDE method to get the instance of the ide.\n */\nexport default class DiagramIDE {\n    ideId: string;\n    validatedSchemas: Map<string, CustomSchema>;\n    schemaMethods: Map<string, SchemaMethodBundle>;\n\n    displaySchemaId: string;\n\n    private static globalNextId = 0;\n\n    public static getID(): string {\n        return String(DiagramIDE.globalNextId++);\n    }\n\n\n    private static instance: DiagramIDE;\n\n\n    /**\n     * Private constructor\n     * @param ideId the ID of the DOM element where the IDE diagram should be rendered\n     */\n    private constructor(ideId: string) {\n        this.validatedSchemas = new Map();\n        this.schemaMethods = new Map();\n        this.displaySchemaId = 'main';\n        this.ideId = ideId;\n    }\n\n    public static getIDE() {\n        if (!DiagramIDE.instance) {\n            DiagramIDE.instance = new DiagramIDE(IDE_ID);\n        }\n\n        return DiagramIDE.instance;\n    }\n\n    /**\n     * Renders diagram RFC in the DOM element with the ideId as the id.\n     * This method is only called when a fresh diagram is needed; it is\n     * not called when an existing diagram needs updating.\n     */\n    public renderDiagram() {\n        console.log('rendering IDE');\n\n        let toRender = (<div>\n            <UncontrolledDiagram schemaId={this.displaySchemaId} />\n        </div>);\n\n        ReactDOM.render(toRender, document.getElementById(this.ideId));\n    }\n\n    /**\n     * Unmounts the current diagram and calls renderDiagram.\n     */\n    public redrawDiagram() {\n        let leRoot = document.getElementById(this.ideId);\n        if (leRoot) {\n            ReactDOM.unmountComponentAtNode(leRoot);\n        }\n        this.renderDiagram();\n    }\n\n    /**\n     * Add a VALIDATED schema to the diagram before a diagram is unmounted.\n     * @param schemaId id of schema being added\n     * @param schema schema being added\n     * @param methods a bundle of schema methods\n     */\n    public addSchema(schemaId: string, schema: CustomSchema, methods: SchemaMethodBundle): void {\n        this.validatedSchemas.set(schemaId, schema);\n        this.schemaMethods.set(schemaId, methods)\n    }\n\n    /**\n     * Setter for displaySchemaId. Should be used to change to an EXISTING\n     * schema. Calls redrawDiagram to update DOM.\n     * @param schemaId id of new schema being displayed.\n     */\n    public setDisplaySchemaId(schemaId: string): void {\n        this.displaySchemaId = schemaId;\n        this.redrawDiagram();\n    }\n\n    /**\n     * Loads validated schemas from save; calls to rerender.\n     * @param schemas validated schemas from the save\n     * @param startID the new value for the node id counter\n     */\n    public loadSchemas(schemas: Map<string, CustomSchema>, startID: string): void {\n        this.validatedSchemas = schemas;\n        DiagramIDE.globalNextId = Number(startID);\n        this.schemaMethods = new Map(); // old methods no longer valid\n\n        this.displaySchemaId = 'main';\n        this.redrawDiagram();\n    }\n\n    /**\n     * Searches through schema to find nodes with nodeId and flag them as problematic.\n     * This is done when a node throws a TeaBlocksError.\n     * \n     * @param nodeId the id's of nodes that are to be flagged as problematic.\n     */\n    public flagNodes(...nodeId: string[]): void {\n        nodeId.forEach(id => {\n            for (let schema of Array.from(this.validatedSchemas.values())) {\n                let foundNode = schema.nodes.find(node => node.id === id);\n                if (foundNode) {\n                    foundNode.data.problematic = true;\n                    console.log(`Flagged ${id}!`);\n                    break;\n                }\n            }\n        })\n    }\n\n    /**\n     * Goes through each node in each schema and sets the problematic flag to\n     * false.\n     */\n    public unflagNodes(): void {\n        this.validatedSchemas.forEach(schema => {\n            schema.nodes.forEach(node => node.data.problematic = false);\n        })\n    }\n}\n","import { ReturnBlock } from \"../ReturnBlock\";\n\n/**\n * A boolean return block that gets if the button is pressed or not\n */\nexport class ButtonStatusBlock extends ReturnBlock {\n    buttonName: string;\n\n    /**\n     * Constructor\n     * @param id the id.\n     * @param buttonName the unique name of this button (what the user sees)\n     */\n    constructor(id: string, buttonName: string) {\n        super(id);\n        this.buttonName = buttonName;\n    }\n\n    /**\n     * Gets the value of '$btn-buttonName' from variable environment.\n     * @param varEnv variable environment\n     * @returns the boolean value of the button status (false if it does not exist);\n     */\n    evalBlock(varEnv: Map<string, any>) {\n        let val = varEnv.get('&btn-' + this.buttonName); //! come back to this\n        return Boolean(val);\n    }\n\n}","import { TeaBlocksError } from './../../TeaBlocksError';\nimport { AssemblyJoystick } from './AssemblyJoystick';\nimport { ReturnBlock } from \"../ReturnBlock\";\n\n/**\n * Gets the x value from a joystick with a specific name. Does not create the joystick.\n */\nexport class JoyXStatusBlock extends ReturnBlock {\n    joyName: string;\n\n    constructor(id: string, joyName: string) {\n        super(id)\n        this.joyName = joyName;\n    }\n\n    /**\n     * Returns the x value of joystick. I.e. the x value of '&joyName'\n     * @param varEnv variable environment\n     */\n    evalBlock(varEnv: Map<string, any>) {\n        let vName = '&' + this.joyName;\n\n        if (!varEnv.has(vName)) throw new TeaBlocksError(`Joystick ${this.joyName} does not exist`, this.id);\n\n        let joy: AssemblyJoystick = varEnv.get(vName);\n\n        return joy.x;\n    }\n}","import { TeaBlocksError } from './../../TeaBlocksError';\nimport { AssemblyJoystick } from './AssemblyJoystick';\nimport { ReturnBlock } from \"../ReturnBlock\";\n\n/**\n * Gets the y value from a joystick with a specific name. Does not create the joystick.\n */\nexport class JoyYStatusBlock extends ReturnBlock {\n    joyName: string;\n\n    constructor(id: string, joyName: string) {\n        super(id)\n        this.joyName = joyName;\n    }\n\n    /**\n     * Returns the y value of joystick. I.e. the y value of '&joyName'\n     * @param varEnv variable environment\n     */\n    evalBlock(varEnv: Map<string, any>) {\n        let vName = '&' + this.joyName;\n\n        if (!varEnv.has(vName)) throw new TeaBlocksError(`Joystick ${this.joyName} does not exist`, this.id);\n\n        let joy: AssemblyJoystick = varEnv.get(vName);\n\n        return joy.y;\n    }\n}","import { Button } from 'beautiful-react-ui';\nimport '../../styles/CustomRender.scss';\nimport { RenderProps } from './RenderProps';\nimport { RenderHelper } from './RenderHelper';\n\nexport function CustomRender(props: RenderProps) {\n    \n    let inpDivs = props.inputs ? RenderHelper.makeInputDivs(props.inputs, props.data.inputNames) : [];\n    let outDivs = props.outputs ? RenderHelper.makeOutputDivs(props.outputs, props.data.outputNames) : [];\n \n    return (\n        <div className={\"node-wrapper\"}>\n            <div className={props.data.problematic ? \"custom-node-problem\" : \"custom-node\"} >\n                <div className=\"deleteBtn\">\n                    <Button icon=\"times\" size=\"small\" onClick={() => RenderHelper.deleteNode(props.data.parentSchema, props.id)} />\n                </div>\n                <div className=\"ports\">\n                    <div className=\"inputs\">\n                        {inpDivs}\n                    </div>\n                    <div className=\"content\">\n                        {props.content}\n                    </div>\n                    <div className=\"outputs\">\n                        {outDivs}\n                    </div>\n                </div>\n            </div>\n        </div>\n    )\n}\n\n","import React from 'react'\nimport { Button } from 'beautiful-react-ui';\nimport '../../styles/SpecialRender.scss';\nimport DiagramIDE from '../../ide/DiagramIDE';\nimport { RenderProps } from './RenderProps';\nimport { RenderHelper } from './RenderHelper';\n\nexport function IfRender(props: RenderProps) {\n    let inpDivs = props.inputs ? RenderHelper.makeInputDivs(props.inputs, props.data.inputNames) : [];\n\n    function trueButton() {\n        console.log(\"Clicked True button! (going to if schema)\");\n        DiagramIDE.getIDE().setDisplaySchemaId(`${props.id}if`);\n    }\n\n    function falseButton() {\n        console.log(\"Clicked False button! (going to else schema)\");\n        DiagramIDE.getIDE().setDisplaySchemaId(`${props.id}else`);\n    }\n\n    return (\n        <div>\n            <div className=\"if-node\" >\n                <div className=\"deleteBtn\">\n                    <Button icon=\"times\" size=\"small\" onClick={() => RenderHelper.deleteNode(props.data.parentSchema, props.id)} />\n                </div>\n\n                <div className=\"ports\">\n                    <div className=\"inputs\">\n                        {inpDivs}\n                    </div>\n                    <div className=\"content\">\n                        {props.content}\n                    </div>\n                </div>\n                <div className=\"buttons\">\n                    <button className=\"true-btn\" onClick={trueButton}>True</button>\n                    <button className=\"false-btn\" onClick={falseButton}>False</button>\n                </div>\n            </div>\n        </div>\n    )\n}\n\n","import { Button } from 'beautiful-react-ui';\nimport '../../styles/SpecialRender.scss';\nimport DiagramIDE from '../../ide/DiagramIDE';\nimport { RenderProps } from './RenderProps';\nimport { RenderHelper } from './RenderHelper';\n\nexport function WhileRender(props: RenderProps) {\n    let inpDivs = props.inputs ? RenderHelper.makeInputDivs(props.inputs, props.data.inputNames) : [];\n\n    function loopButton() {\n        console.log(\"Clicked loop button!\");\n        DiagramIDE.getIDE().setDisplaySchemaId(`${props.id}while`);\n    }\n\n    return (\n        <div>\n            <div className=\"while-node\">\n                <div className=\"deleteBtn\">\n                    <Button icon=\"times\" size=\"small\" onClick={() => RenderHelper.deleteNode(props.data.parentSchema, props.id)} />\n                </div>\n                <div className=\"ports\">\n                    <div className=\"inputs\">\n                        {inpDivs}\n                    </div>\n                    <div className=\"content\">\n                        {props.content}\n                    </div>\n                </div>\n                <div className=\"buttons\">\n                    <button className=\"loop-btn\" onClick={loopButton}>Loop</button>\n                </div>\n            </div>\n        </div>\n    )\n}\n\n","import { NodeData } from './NodeData';\nimport { BlockType } from './../compiler/factory/BlockType';\nimport { Node, NodeCoordinates, Port } from 'beautiful-react-diagrams/@types/DiagramSchema';\nimport { ElementType, ReactNode } from 'react';\nimport { CustomNode } from './CustomNode';\nimport DiagramIDE from '../ide/DiagramIDE';\n\n\nexport class FunctionNode implements CustomNode {\n    id: string;\n    coordinates: NodeCoordinates;\n    content: ReactNode;\n    inputs: Port[];\n    outputs: Port[];\n    data: NodeData;\n    render: (props: Omit<Node<any>, 'coordinates'>) => ElementType | ReactNode;\n\n    blockType: BlockType;\n    constInputs: any[];\n\n    /**\n     * \n     * @param content content of this node\n     * @param coordinates inital coordinates of the node\n     * @param numInputs the number of input ports this node should have\n     * @param numOutputs the number of output ports this node should have\n     * @param blockType the type of the assembly block created (for phasing out assConstructor)\n     * @param constInputs constant inputs that assembly block takes.\n     * @param data data of the node (any object; should contain assConstructor)\n     * @param render renderer used to render\n     * ! ^ data is kinda weird. need to figure out how to replace it with more concrete/safe types.\n     */\n    constructor(content: ReactNode,\n        coordinates: NodeCoordinates,\n        numInputs: number,\n        numOutputs: number,\n        blockType: BlockType,\n        constInputs: any[],\n        data: NodeData,\n        render: (props: Omit<Node<any>, 'coordinates'>) => ElementType | ReactNode) {\n\n        this.id = DiagramIDE.getID()\n        this.coordinates = coordinates;\n        this.content = content;\n        this.data = data;\n        this.render = render;\n\n        this.blockType = blockType;\n        this.constInputs = constInputs;\n\n        this.outputs = [];\n        for (let i = 0; i < numOutputs; i++) {\n            let port: Port = { id: this.id + '-output-' + i };\n            this.outputs.push(port);\n        }\n\n        this.inputs = [];\n        for (let i = 0; i < numInputs; i++) {\n            let port: Port = { id: this.id + '-input-' + i };\n            this.inputs.push(port);\n        }\n    }\n\n\n\n}","import { NodeData } from './NodeData';\nimport { BlockType } from './../compiler/factory/BlockType';\nimport { Node } from 'beautiful-react-diagrams/@types/DiagramSchema';\nimport { NodeCoordinates } from 'beautiful-react-diagrams/@types/DiagramSchema';\nimport { ElementType, ReactNode } from 'react';\nimport { OutputNode } from './OutputNode';\n\n/**\n * A code block IfNode\n */\nexport class IfNode extends OutputNode {\n    constructor(content: ReactNode,\n        coordinates: NodeCoordinates,\n        constInputs: any[],\n        data: NodeData,\n        render: (props: Omit<Node<any>, 'coordinates'>) => ElementType | ReactNode) {\n        //todo replace with custom renderer\n        super(content, coordinates, 1, BlockType.IF, constInputs, data, render);\n    }\n}","import { NodeData } from './NodeData';\nimport { BlockType } from './../compiler/factory/BlockType';\nimport { Node } from 'beautiful-react-diagrams/@types/DiagramSchema';\nimport { NodeCoordinates } from 'beautiful-react-diagrams/@types/DiagramSchema';\nimport { ElementType, ReactNode } from 'react';\nimport { OutputNode } from './OutputNode';\n\n/**\n * A code block WhileNode\n */\nexport class WhileNode extends OutputNode {\n    constructor(content: ReactNode,\n        coordinates: NodeCoordinates,\n        constInputs: any[],\n        data: NodeData,\n        render: (props: Omit<Node<any>, 'coordinates'>) => ElementType | ReactNode) {\n        //todo replace with custom renderer\n        super(content, coordinates, 1, BlockType.WHILE, constInputs, data, render);\n    }\n}","import '../../styles/CustomRender.scss';\nimport React from 'react';\nimport DiagramIDE from '../../ide/DiagramIDE';\n\n/**\n * A JavaScript class to do the type-ambiguous dirtywork for TypeScript Renderers.\n * If things go wrong it's all in this class.\n */\nexport class RenderHelper {\n    /**\n     * Makes the React elements for the input ports.\n     * @param inputs the input ports\n     * @param inputNames the list of names of input ports\n     * @returns {ReactNode[]}\n     */\n    static makeInputDivs(inputs, inputNames) {\n        let inpDivs = [];\n        if (inputs) {\n            for (let ix = 0; ix < inputs.length; ix++) {\n                inpDivs.push((\n                    <div className='InputPortDiv' key={inputs[ix].key + 'div'}>\n                        {React.cloneElement(inputs[ix], { className: \"port\" })}\n                        {inputNames && <label>{inputNames[ix]}</label>}\n                    </div>\n                ));\n            }\n        }\n\n        return inpDivs;\n    }\n\n    /**\n     * Makes the React elements for the output ports.\n     * @param outputs the output ports\n     * @param outputNames the list of names of output ports\n     * @returns {ReactNode[]}\n     */\n    static makeOutputDivs(outputs, outputNames) {\n        let outDivs = [];\n        if (outputs) {\n            for (let ix = 0; ix < outputs.length; ix++) {\n                outDivs.push((\n                    <div className='OutputPortDiv' key={outputs[ix].key + 'div'}>\n                        {outputNames && <label>{outputNames[ix]}</label>}\n                        {React.cloneElement(outputs[ix], { className: \"port\" })}\n\n                    </div>\n                ));\n            }\n        }\n\n        return outDivs;\n    }\n\n    static deleteNode(parentSchema, id) {\n        DiagramIDE.getIDE()\n            .schemaMethods\n            .get(parentSchema)\n            .deleteNodeFromSchema(id);\n    }\n}","export * from './CustomRender';\nexport * from './IfRender';\nexport * from './RenderProps';\nexport * from './WhileRender';\nexport * from './RenderHelper';\n\n","/**\n * A custom error for when something goes wrong with the internals of the compiler.\n * Serious software gore territory.\n */\nexport class InternalCompilerError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'InternalCompilerError';\n\n    }\n}","export enum ShapeColor {\n    BLACK = 'rgb(0,0,0)',\n    WHITE = 'rgb(255,255,255)',\n    GREY = 'rgb(155,155,155)',\n    RED = 'rgb(255,0,0)',\n    GREEN = 'rgb(0,255,0)',\n    BLUE = 'rgb(0,0,255)',\n    YELLOW = 'rgb(255,255,0)',\n    PURPLE = 'rgb(128,0,128)',\n    BROWN = 'rgb(110,60,34)',\n    ORANGE = 'rgb(255,89,0)',\n    PINK = 'rgb(255,0,255)',\n}","import { Shape } from './Shape';\nimport { TeaBlocksError } from './../../TeaBlocksError';\nimport { ReturnBlock } from \"../ReturnBlock\";\n\n/**\n * Gets the x position of a shape\n */\nexport class GetXBlock extends ReturnBlock {\n    shape: ReturnBlock\n\n    /**\n     * Constructor\n     * @param id the id\n     * @param inputs inputs[0] is the get shape.\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id);\n        this.shape = inputs[0];\n    }\n\n    /**\n     * Returns x position.\n     * @param varEnv variable environment\n     */\n    evalBlock(varEnv: Map<string, any>){\n        let shapeName = this.shape.evalBlock(varEnv);\n\n        let shape: Shape = varEnv.get(shapeName);\n        \n        if(!shape) throw new TeaBlocksError('This shape does not exist', this.id);\n\n        return shape.posX;\n    }\n}","import { Shape } from './Shape';\nimport { TeaBlocksError } from './../../TeaBlocksError';\nimport { ReturnBlock } from \"../ReturnBlock\";\n\n/**\n * Gets the y position of a shape\n */\nexport class GetYBlock extends ReturnBlock {\n    shape: ReturnBlock\n\n    /**\n     * Constructor\n     * @param id the id\n     * @param inputs inputs[0] is the get shape.\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id);\n        this.shape = inputs[0];\n    }\n\n    /**\n     * Returns y position.\n     * @param varEnv variable environment\n     */\n    evalBlock(varEnv: Map<string, any>){\n        let shapeName = this.shape.evalBlock(varEnv);\n\n        let shape: Shape = varEnv.get(shapeName);\n        \n        if(!shape) throw new TeaBlocksError('This shape does not exist', this.id);\n\n        return shape.posY;\n    }\n}","import { TeaBlocksError } from './../../TeaBlocksError';\nimport { ReturnBlock } from \"../ReturnBlock\";\nimport { VoidBlock } from \"../VoidBlock\";\nimport { Shape } from \"./Shape\";\n\n/**\n * Block for moving a shape.\n */\nexport class MoveBlock extends VoidBlock {\n    shape: ReturnBlock; // a GetShapeBlock, tho madlads can use constants that start with $.\n    x: ReturnBlock;\n    y: ReturnBlock;\n\n    /**\n     * Constructor\n     * @param inputs the inputs (shape is inputs[0]; x is inputs[1]; y is inputs[2])\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.shape = inputs[0];\n        this.x = inputs[1];\n        this.y = inputs[2];\n    }\n\n    /**\n     * Adds x and y to the position of the shape.\n     * @param varEnv variable environment\n     */\n    *evalBlock(varEnv: Map<string, any>) {\n        let shapeName: string = String(this.shape.evalBlock(varEnv));\n        let shape: Shape = varEnv.get(shapeName);\n\n        if(!shape) throw new TeaBlocksError('This shape does not exist', this.id);\n\n        let x = Number(this.x.evalBlock(varEnv));\n        let y = Number(this.y.evalBlock(varEnv));\n\n        if (isNaN(x)|| isNaN(y)) {\n            throw new TeaBlocksError(\"Input not a number\", this.id);\n        }\n\n        shape.posX += x;\n        shape.posY += y;\n\n        varEnv.set(shapeName, shape);\n\n        yield;\n    }\n\n\n}","import { TeaBlocksError } from './../../TeaBlocksError';\nimport { ReturnBlock } from \"../ReturnBlock\";\nimport { VoidBlock } from \"../VoidBlock\";\nimport { Shape } from \"./Shape\";\n\n/**\n * Block for rotating a shape (by degrees).\n */\nexport class RotateBlock extends VoidBlock {\n    shape: ReturnBlock; // a GetShapeBlock, tho madlads can use constants that start with $.\n    rot: ReturnBlock;\n\n    /**\n     * Constructor\n     * @param inputs the inputs (shape is inputs[0]; rotation is inputs[1])\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.shape = inputs[0];\n        this.rot = inputs[1];\n    }\n\n    /**\n     * Adds rot to the rotation of the shape.\n     * @param varEnv variable environment\n     */\n    *evalBlock(varEnv: Map<string, any>) {\n        let shapeName: string = String(this.shape.evalBlock(varEnv));\n        let shape: Shape = varEnv.get(shapeName);\n\n        if(!shape) throw new TeaBlocksError('This shape does not exist', this.id);\n\n        let rot = Number(this.rot.evalBlock(varEnv));\n\n        if (isNaN(rot)) {\n            throw new TeaBlocksError(\"Input not a number\", this.id);\n        }\n\n        shape.rot += rot;\n\n        varEnv.set(shapeName, shape);\n\n        yield;\n    }\n\n\n}","import { TeaBlocksError } from './../../TeaBlocksError';\nimport { ReturnBlock } from \"../ReturnBlock\";\nimport { VoidBlock } from \"../VoidBlock\";\nimport { Shape } from \"./Shape\";\n\n/**\n * Block for scaling a shape (multiplier).\n */\nexport class ScaleBlock extends VoidBlock {\n    shape: ReturnBlock; // a GetShapeBlock, tho madlads can use constants that start with $.\n    x: ReturnBlock;\n    y: ReturnBlock;\n\n    /**\n     * Constructor\n     * @param inputs the inputs (shape is inputs[0]; x is inputs[1]; y is inputs[2])\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.shape = inputs[0];\n        this.x = inputs[1];\n        this.y = inputs[2];\n    }\n\n    /**\n     * Multiplies x and y to the scale of the shape.\n     * @param varEnv variable environment\n     */\n    *evalBlock(varEnv: Map<string, any>) {\n        let shapeName: string = String(this.shape.evalBlock(varEnv));\n        let shape: Shape = varEnv.get(shapeName);\n\n        if(!shape) throw new TeaBlocksError('This shape does not exist', this.id);\n\n        let x = Number(this.x.evalBlock(varEnv));\n        let y = Number(this.y.evalBlock(varEnv));\n\n        if (isNaN(x) || isNaN(y)) {\n            throw new TeaBlocksError(\"Input not a number\", this.id);\n        }\n\n        shape.scaleX *= x;\n        shape.scaleY *= y;\n\n        varEnv.set(shapeName, shape);\n\n        yield;\n    }\n\n\n}","export enum ShapeType{\n    RECT='Rectangle',\n    CIRCLE='Circle',\n    TRIANGLE='Triangle',\n    STAR='Star',\n    HEART='Heart',\n}","import { InternalCompilerError } from './InternalCompilerError';\nimport { AbstractBlock } from \"./assemblyBlocks/AbstractBlock\";\nimport { VoidBlock } from \"./assemblyBlocks/VoidBlock\";\n\nvar interuptSignal = false; // stop signal\n\n/**\n * Class for a user-created program.\n */\nexport class Program {\n    subroutines: AbstractBlock[];\n    triggerDict: Map<string, number[]>;\n    varEnv: Map<string, any>;\n\n    triggeredIndexes: Set<number>;\n\n    taskQueue: [IterableIterator<void>, number][];\n\n    // function that gets called when an error happens. Should be injected\n    errorNotify: (message: string, ...nodeId: string[]) => void;\n\n    /**\n     * Constructor\n     * @param subroutines list of abstract block trees in order (including triggered subroutines)/\n     */\n    constructor(subroutines: AbstractBlock[], triggerDict: Map<string, number[]>) {\n        this.subroutines = subroutines;\n        this.triggerDict = triggerDict;\n        this.varEnv = new Map();\n        this.taskQueue = [];\n        this.errorNotify = (message: string, ...nodeId: string[]) => { console.log('Unhandled Runtime Error') };\n\n        this.triggeredIndexes = new Set();\n\n        triggerDict.forEach((ixArr) => {\n            ixArr.forEach(ix => this.triggeredIndexes.add(ix));\n        })\n\n        console.log('trigger map');\n        console.log(triggerDict);\n\n        console.log(`THERE ARE ${this.subroutines.length} subroutines`);\n    }\n\n    /**\n     * Runs the subroutines triggered by trigName, in order.\n     * Does not clear varEnv.\n     * \n     * @param trigName the name of the trigger\n     */\n    trigger(trigName: string): void {\n        // this.taskQueue = [];\n\n        if (!this.triggerDict.has(trigName)) {\n            console.log(`${trigName} is not a defined trigger`);\n            return;\n        }\n\n        this.triggerDict.get(trigName)?.forEach(t => {\n            let sub = this.subroutines[t];\n            if(!(sub instanceof VoidBlock)) throw new InternalCompilerError('Subroutine not Void!');\n            this.buildTaskQueue(sub.evalBlock(this.varEnv), sub.getLength());\n        });\n\n        this.scheduleNextTask();\n\n    }\n\n    /**\n     * Schedules execution of the program to stop.\n     */\n    stop() {\n        console.log('scheduling to stop!');\n        interuptSignal = true;\n    }\n\n\n    /**\n     * Schedules untriggered subroutines for execution.\n     */\n    run() {\n        interuptSignal = false;\n        this.taskQueue = []\n\n        this.varEnv = new Map();\n\n        this.subroutines.filter((val, ix) => !this.triggeredIndexes.has(ix))\n            .forEach(task => {\n                if(!(task instanceof VoidBlock)) throw new InternalCompilerError('Task is not a Void!');\n\n                let gen = task.evalBlock(this.varEnv);\n                this.buildTaskQueue(gen, task.getLength());\n            });\n\n        this.scheduleNextTask();\n\n    }\n\n    /**\n     * Adds a task to the task queue\n     * @param task task being added to queue\n     */\n    private buildTaskQueue(task: IterableIterator<void>, length: number) {\n        this.taskQueue.push([task, length]);\n    }\n\n    /**\n     * Recursive execution loop using requestAnimationFrame. Executsts the generator\n     * cycle. If the current generator is done, it asks for the next task.\n     * Stops executing if scheduled to stop.\n     * \n     * @param task current task being worked on\n     * @param length the number of steps to execute this task\n     */\n    private eventLoop(task: IterableIterator<void>, length: number) {\n        if (interuptSignal) {\n            this.stopCleanup();\n            return;\n        }\n        let status;\n\n        try {\n            let count = 0;\n            let s;\n\n            do {\n                s = task.next();\n            } while (++count < length);\n\n            status = s.done;\n\n        } catch (err) {\n            console.error(err);\n            console.log('CAUGHT AN ERROR')\n\n            interuptSignal = true;\n            this.taskQueue = [];\n\n            // eslint-disable-next-line eqeqeq\n            if (err.name == 'TeaBlocksError') {\n                console.log('TEABLOCKS ERROR!!!')\n                this.errorNotify(err.message, err.id);\n                console.log(err);\n            } else {\n                console.log('UNHANDLED ERROR!!');\n                throw err;\n            }\n\n        }\n\n        if (status) {\n            this.scheduleNextTask();\n        } else {\n            window.requestAnimationFrame(_ => this.eventLoop(task, length));\n            // setTimeout(_ => this.eventLoop(task, length), 0);\n        }\n    }\n\n    /**\n     * Schedules the next task for execution, if there is a next task.\n     */\n    private scheduleNextTask() {\n        let nextTask = this.taskQueue.shift();\n        if (nextTask == null) return;\n        let [aaa, length] = nextTask;\n        window.requestAnimationFrame(_ => this.eventLoop(aaa, length));\n        // setTimeout(_ => this.eventLoop(aaa, length),0)\n\n    }\n\n    private stopCleanup() {\n        this.varEnv = new Map();\n        this.taskQueue = [];\n    }\n}","import { AbstractBlock } from './assemblyBlocks/AbstractBlock';\nimport { Program } from './Program';\nimport { StateNode } from './state/StateNode';\nimport { createAssemblyBlock, BlockType } from './factory';\n\n/**\n * Compiles the StateNodes into Program.\n * \n * @param trees root nodes of trees (precompiled)\n * @returns a Program compiled from the root nodes\n */\nexport default async function compile(trees: StateNode[]) {\n\n    /**\n     * Compiles a single StateNode tree root node into a tree of AssemblyBlocks.\n     * Returns a set of all the names of triggers that trigger this tree.\n     * \n     * @param node node being compiled\n     * @returns a tuple of the corresponding abstract block for this node \n     *    (populated as a tree with children) and the set of trigger names for this tree.\n     */\n    function compileTree(node: StateNode): [AbstractBlock, Set<string>] {\n        console.log(\"Entering Compile Tree\");\n        if (node.hasBeenCompiled) throw new EvalError(\"Looping tree? (In Compiler)\");\n\n        node.hasBeenCompiled = true; // flags node as being compiled\n\n        if (node.isInput) {\n            console.log(\"We an input (base case)\");\n            let compiledNode: AbstractBlock = createAssemblyBlock(node.nodeId, node.blockType, ...node.constInputs);\n\n            let trigSet: Set<string> = new Set();\n            if (node.isTriggered) {\n                console.log(`${node.constInputs[0]} is this node's trigger`);\n                trigSet.add(node.constInputs[0]); //! 0th index is the trigger name\n            }\n\n            return [compiledNode, trigSet];\n        } else if (node.blockType === BlockType.IF || node.blockType === BlockType.WHILE) {\n            console.log(\"IF BLOCK/ WHILE BLOCK\");\n            let thisNodeChildren = node.children;\n            console.log(\"Length of children: \" + thisNodeChildren.length);\n            // let inputs: AbstractBlock[] = [];\n            let trigSet: Set<string> = new Set();\n\n            // inputs will be [[condition], [if], [else]]\n            let inputs = thisNodeChildren.map(childArr => {\n                let compiledArr = childArr.map(child => {\n                    console.log('Compiling child');\n                    let [compiledChild, trig] = compileTree(child);\n                    console.log('Done compiling child');\n\n                    trig.forEach(t => trigSet.add(t));\n\n                    return compiledChild;\n                });\n\n                return compiledArr;\n            });\n\n            console.log('Done compiling children');\n            let compiledNode = createAssemblyBlock(node.nodeId, node.blockType, ...node.constInputs, inputs); //! <---\n            console.log('Returning');\n\n            return [compiledNode, trigSet];\n\n        } else {     //todo other cases stuff\n            console.log(\"We not input (recursive)\");\n            let [thisNodeChildren] = node.children;\n            console.log(\"Length of children: \" + thisNodeChildren.length);\n            let inputs: AbstractBlock[] = [];\n            let trigSet: Set<string> = new Set();\n\n            for (let child of thisNodeChildren) {\n                console.log('Compiling child');\n                let [compiledChild, trig] = compileTree(child);\n                console.log('Done compiling child');\n\n                inputs.push(compiledChild);\n                trig.forEach(t => trigSet.add(t));\n            }\n\n            if (node.isTriggered) {\n                // this can't happen because only inputs are triggered\n                // may be deleted later when finalized\n                trigSet.add(node.constInputs[0]);\n            }\n\n            console.log('Done compiling children');\n            let compiledNode = createAssemblyBlock(node.nodeId, node.blockType, ...node.constInputs, inputs); //! <---\n            console.log('Returning');\n\n            return [compiledNode, trigSet];\n        }\n\n    }\n\n    let subroutines: AbstractBlock[] = Array(trees.length);\n    let triggerDict: Map<string, number[]> = new Map();\n\n    console.log('BEGINING COMPILING');\n    console.log('We have ' + trees.length + ' trees');\n\n    for (let ix = 0; ix < trees.length; ix++) {\n        console.log('COMPILING THIS NODE');\n        let [subroutine, trigSet] = compileTree(trees[ix]);\n        console.log('DONE COMPILING THIS NODE');\n        subroutines[ix] = subroutine;\n\n        console.log(`Trigset:`);\n        console.log(trigSet);\n\n        trigSet.forEach(trig => {\n            console.log('Trig:' + trig);\n            if (triggerDict.has(trig)) {\n                triggerDict.get(trig)?.push(ix);\n            } else {\n                triggerDict.set(trig, [ix]);\n            }\n        })\n\n\n    }\n\n\n    return new Program(subroutines, triggerDict);\n}","import React, { useRef, useEffect } from 'react'\n\n// https://medium.com/@pdx.lucasm/canvas-with-react-js-32e133c05258\nconst Canvas = props => {\n\n    const { draw, ...rest } = props\n    const canvasRef = useRef(null)\n\n    useEffect(() => {\n\n        const canvas = canvasRef.current\n        const context = canvas.getContext('2d')\n        let frameCount = 0\n        let animationFrameId\n\n        // https://stackoverflow.com/questions/10214873/make-canvas-as-wide-and-as-high-as-parent\n        \n        // Make it visually fill the positioned parent\n        canvas.style.width = '100%';\n        canvas.style.height = '100%';\n\n        // ...then set the internal size to match\n        canvas.width = canvas.offsetWidth;\n        canvas.height = canvas.offsetHeight;\n\n        const render = () => {\n            frameCount++\n            draw(context, frameCount)\n            animationFrameId = window.requestAnimationFrame(render)\n        }\n        render()\n\n        return () => {\n            window.cancelAnimationFrame(animationFrameId)\n        }\n    }, [draw])\n\n    return <canvas ref={canvasRef} {...rest} />\n}\n\nexport default Canvas","import {  Component } from 'react'\nimport { Joystick } from 'react-joystick-component';\nimport { AssemblyJoystick } from '../compiler/assemblyBlocks/inputBlocks';\nimport { IJoystickUpdateEvent } from 'react-joystick-component/build/lib/Joystick';\nimport { Shape } from '../compiler/assemblyBlocks/shape/Shape';\nimport { ShapeType } from '../compiler/assemblyBlocks/shape/ShapeType';\nimport { Program } from '../compiler/Program';\nimport Canvas from './Canvas';\nimport '../styles/Runtime.scss';\nimport ReactDOM from 'react-dom';\n\n\ninterface Prop {\n    program: Program;\n}\n\ninterface State {\n    inputs: any[]\n}\n\n// let lastX = 0;\n// let lastY = 0;\n\ninterface InputValue {\n    started: boolean,\n    x: number,\n    y: number\n}\n\nexport default class Runtime extends Component<Prop, State> {\n    program: Program;\n    inputStorage: Map<string, InputValue>;\n\n    constructor(props: Prop) {\n        super(props);\n        console.log(\"--RUNTIME           Entered Runtime constructor\");\n        this.state = ({\n            inputs: []\n        });\n        this.program = props.program;\n        this.inputStorage = new Map();\n\n        this.draw = this.draw.bind(this);\n        this.setup = this.setup.bind(this);\n\n    }\n\n    moveThing(inputVal: InputValue, inputName: string) {\n        // console.log(inputVal, inputName);\n        if (inputVal.started) {\n            let newJoy: AssemblyJoystick = { x: inputVal.x, y: inputVal.y };\n            this.program.varEnv.set(`&${inputName}`, newJoy);\n            this.program.trigger(`${inputName}`); //! hope this work\n        }\n    }\n\n\n    setup() {\n        console.log(\"--RUNTIME           called setup !!!!\", this.program.varEnv, this.program.triggerDict, \"asdasd\");\n        if (this.program.triggerDict.size === this.state.inputs.length) return;\n\n        this.program.varEnv.forEach((value: any, key: string) => {\n            let joystickName = key.substring(1); // gets rid of the $\n            if (value.type === \"joy\" && !this.inputStorage.has(joystickName)) {\n                console.log(\"--RUNTIME           \", value);\n\n\n                let joystick =\n                    (<div className={joystickName} style={{ position: 'absolute', left: value.x, bottom: value.y }} key={joystickName}>\n                        <Joystick\n                            size={100}\n                            baseColor=\"#7c7cf3\"\n                            stickColor=\"#efefef\"\n                            move={(e: IJoystickUpdateEvent) => { this.handleMove(e, joystickName) }}\n                            stop={(e: IJoystickUpdateEvent) => { this.handleStop(e, joystickName) }}\n                            start={(e: IJoystickUpdateEvent) => { this.handleStart(e, joystickName) }}>\n                        </Joystick>\n                    </div>);\n\n                let inpVal: InputValue = {\n                    started: false,\n                    x: 0,\n                    y: 0\n                }\n\n                this.inputStorage.set(joystickName, inpVal)\n                this.setState(prevState => ({\n                    inputs: [...prevState.inputs, joystick]\n                }))\n                this.program.varEnv.set(`&${joystickName}`, { x: 0, y: 0 });\n\n            } else if (value.type === \"btn\") {\n                // todo: haven't implemented yet \n            }\n        })\n    }\n\n    componentDidMount() {\n        this.setup();\n    }\n\n    draw(ctx: CanvasRenderingContext2D, frameCount: number) {\n        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n        if (this.state.inputs.length < this.program.triggerDict.size) {\n            this.setup();\n        }\n\n        this.inputStorage.forEach((value: InputValue, key: string) => {\n            this.moveThing(value, key);\n        })\n\n\n        if (this.program.subroutines.length > 0) { // Check if the program compiled   \n            this.program.varEnv.forEach((value, key: string) => {\n                switch (value.constructor) {\n                    case Shape:\n                        this.addShape(ctx, value);\n                        break;\n                    default:\n                }\n            });\n        }\n    }\n\n    handleMove(e: IJoystickUpdateEvent, inputName: string) {\n        if (e.x && e.y) {\n            if (this.inputStorage.get(inputName)) {\n                let newVals: InputValue = { started: this.inputStorage.get(inputName)?.started || true, x: e.x / 50, y: - 1 * (e.y / 50) };\n                this.inputStorage.set(inputName, newVals);\n            }\n        }\n    }\n\n    handleStop(e: IJoystickUpdateEvent, inputName: string) {\n        let newVals: InputValue = { started: false, x: 0, y: 0 }\n        this.inputStorage.set(inputName, newVals);\n    }\n\n    handleStart(e: IJoystickUpdateEvent, inputName: string) {\n        if (this.inputStorage.get(inputName)) {\n            let newVals: InputValue = { started: true, x: this.inputStorage.get(inputName)?.x || 0, y: this.inputStorage.get(inputName)?.y || 0 }\n            this.inputStorage.set(inputName, newVals);\n        }\n    }\n\n    addShape(ctx: CanvasRenderingContext2D, element: Shape) {\n        let shapeType: ShapeType = element.type;\n        ctx.fillStyle = element.color;\n        switch (shapeType) {\n            case ShapeType.RECT:\n                this.addRect(ctx, element.posX, element.posY, element.scaleX, element.scaleY);\n                break;\n            case ShapeType.CIRCLE:\n                // addCircle(ctx, element.posX, element.posY, element.scaleX, element.scaleY);\n                break;\n            case ShapeType.TRIANGLE:\n                // addTriangle(ctx, element.posX, element.posY, element.scaleX, element.scaleY);\n                break;\n            case ShapeType.HEART:\n                // addHeart(ctx, element.posX, element.posY, element.scaleX, element.scaleY);\n                break;\n            case ShapeType.STAR:\n                // addStar(ctx, element.posX, element.posY, element.scaleX, element.scaleY);\n                break;\n            default:\n                // console.log('default');\n                break;\n        }\n\n    }\n\n    addRect(ctx: CanvasRenderingContext2D, x: number, y: number, w: number, h: number) {\n        ctx.beginPath()\n        ctx.rect(x, y, w, h);\n        ctx.fill();\n    }\n\n    componentWillUnmount() {\n        let comp = document.getElementById('controller');\n        if (comp) {\n            ReactDOM.unmountComponentAtNode(comp);\n        }\n    }\n\n    render() {\n        return (\n            <div className=\"runtime-section\">\n                <div className=\"runtime-output\">\n                    <Canvas draw={this.draw} />\n                    <div className=\"controller\">\n                        {this.state.inputs}\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n\n","import { BlockType } from './../factory/BlockType';\n\n/**\n * A node of a State tree. The state tree represents the user program as precompiled by the precompiler\n * from the diagram schema. A tree made of these nodes is then passed to the compiler to assemble\n * the assemblyBlocks.\n */\nexport class StateNode {\n    nodeId: string;\n    children: StateNode[][];\n    blockType: BlockType;\n    constInputs: any[];\n    hasBeenCompiled: boolean;\n    isInput: boolean;\n    isTriggered: boolean;\n\n    /**\n     * Constructor.\n     * @param nodeId the id of the corresponding node in diagram schema\n     * @param blockType the type of the corresponding AssemblyBlock\n     * @param constInputs constant (static) inputs needed conr constructing AssemblyBloc\n     * @param isInput true iff this is an input node (without children)\n     */\n    constructor(nodeId: string, blockType: BlockType, constInputs: any[], isInput: boolean) {\n        this.nodeId = nodeId;\n        this.blockType = blockType;\n        this.children = [];\n        this.hasBeenCompiled = false;\n        this.isInput = isInput;\n        this.constInputs = constInputs;\n\n        // todo this needs to be updated when more triggered blocks are added\n        this.isTriggered = blockType === BlockType.BTN_STATUS ||\n            blockType === BlockType.JOY_X ||\n            blockType === BlockType.JOY_Y;\n    }\n}","import { BlockType } from '../compiler/factory/BlockType';\nimport { StateNode } from '../compiler/state/StateNode';\nimport { CustomSchema } from '../diagram/CustomSchema';\nimport { CustomNode } from '../codeBlocks/CustomNode';\nimport { InputNode } from '../codeBlocks/InputNode';\n\nconst RECURSIVE_MAX_DEPTH: number = 500;\n\n/**\n * Sorts roots by grouping them into 25 pixel wide columns based on x coordinate.\n * Sorts groups by horizontal coordinate.\n * Sorts roots inside the groups by vertical coordinate.\n * Merges groups into 1D array in order.\n * \n * @param roots array of roots being sorted. (modifies)\n */\nfunction sortRoots(roots: CustomNode[]): CustomNode[] {\n    roots.sort((a, b) => {\n        return a.coordinates[0] - b.coordinates[0]\n    });\n\n    let groups: CustomNode[][] = [];\n    let groupTracker: [[number, number], number][] = [[[0, 20], 0]];\n\n    for (const root of roots) {\n        let xVal = root.coordinates[0];\n\n        for (var [range, ix] of groupTracker) {\n            if (range[0] <= xVal && xVal < range[1]) {\n                groups[ix].push(root);\n                break;\n            }\n        }\n\n        groupTracker.push([[xVal - 5, xVal + 20], ix + 1]);\n        groups[ix + 1] = [root];\n    }\n\n    groups.map(group => {\n        group.sort((a, b) => a.coordinates[1] - b.coordinates[1])\n        return group;\n    });\n\n\n    return groups.flat();\n}\n\n\n/**\n * Precompiles schema of a diagram into an array of StateNode trees,\n * in order. This array is made compatible to be compiled by the\n * compiler.\n * \n * The precompiler is lazy: only output nodes and nested nodes\n * (such as IF, WHILE, etc.) are considered as root nodes. If\n * a node is not connected to a root node, it is exluded.\n * \n * @param schema map of all diagram schemas in the program (must include 'main')\n * @return state node tree array.\n */\nfunction precompile(schemas: Map<string, CustomSchema>): StateNode[] {\n    console.log(schemas);\n    let ms = schemas.get('main');\n    console.log(ms);\n    let mainSchema: CustomSchema;\n    if (!ms) {\n        throw Error('Main schema must be in schemas')\n    } else {\n        mainSchema = ms;\n    }\n\n    /**\n     * Returns the root nodes of a schema if there are any.\n     * A root is any node that does not have output ports, such\n     * as OutputNodes, IFNodes, NestNodes, etc.\n     * \n     * The roots are sorted by their coordinates. Sorting is based\n     * on horizontal difference. If absolute horizontal difference of \n     * a pair of roots is less than 15, then the pair is ordered by\n     * vertical difference.\n     * \n     * @param schema the schema.\n     * @return root nodes of schema.\n     */\n    function getRoots(schema: CustomSchema): CustomNode[] {\n        let roots: CustomNode[] = [];\n        if (schema.links == null) return roots;\n\n        roots = schema.nodes.filter(node => 'isRoot' in node)\n            // avoids duplicate nodes\n            .filter(function (node: CustomNode, index: number, arr: CustomNode[]) {\n                return arr.indexOf(node) === index;\n            });\n\n        let sorte = sortRoots(roots);\n\n        console.log('roots');\n        console.log(sorte);\n        return sorte;\n    }\n\n    /**\n     * Recursive precompiler helper. Precompiles a root CustomNode and its children recursively.\n     * @param root\n     */\n    function precompRoot(root: CustomNode, depth: number = 0, schema: CustomSchema = mainSchema): StateNode {\n        if (depth >= RECURSIVE_MAX_DEPTH) throw new Error('Looping Tree?\\nReached max recursion depth: ' + RECURSIVE_MAX_DEPTH);\n        depth += 1;\n\n\n        if (isInput(root)) {\n            // base case\n            let comp = new StateNode(root.id, root.blockType, root.constInputs, true);\n            console.log(`Triggered: ${comp.isTriggered}`);\n            return comp;\n\n        } else if (root.blockType === BlockType.IF) {\n            // getting if children\n            let ifSchema = schemas.get(root.id + 'if');\n            if (!ifSchema) throw Error('Encountered If Node without schema');\n            let ifSchemaRoots: CustomNode[] = getRoots(ifSchema);\n\n            let ifChildren: StateNode[] = [];\n\n            for (let innerRoot of ifSchemaRoots) {\n                let compChild = precompRoot(innerRoot, depth, ifSchema);\n                ifChildren.push(compChild);\n            }\n\n            // getting else children\n            let elseSchema = schemas.get(root.id + 'else');\n            if (!elseSchema) throw Error('Encountered If Node without schema');\n            let elseSchemaRoots: CustomNode[] = getRoots(elseSchema);\n\n            let elseChildren: StateNode[] = [];\n\n            for (let innerRoot of elseSchemaRoots) {\n                let compChild = precompRoot(innerRoot, depth, elseSchema);\n                elseChildren.push(compChild);\n            }\n\n            // getting condition\n            let condition = getChildren(root, schema);\n            let compiledCondition = condition.map(child => precompRoot(child, depth, schema));\n\n            // putting it all together\n            let leIf: StateNode = new StateNode(root.id, BlockType.IF, [], false);\n            leIf.children = [compiledCondition, ifChildren, elseChildren];\n            return leIf;\n\n        } else if (root.blockType === BlockType.WHILE) {\n            // compiling while block\n            let whileSchema = schemas.get(root.id + 'while');\n            if (!whileSchema) throw Error('Encountered Nested Node without schema');\n            let whileSchemaRoots: CustomNode[] = getRoots(whileSchema);\n\n            let compiledWhile: StateNode[] = [];\n\n            for (let innerRoot of whileSchemaRoots) {\n                let compChild = precompRoot(innerRoot, depth, whileSchema);\n                compiledWhile.push(compChild);\n            }\n\n            //compiling condition\n            let condition = getChildren(root, schema);\n            console.log(\"my children before precompiling: \");\n            console.log(condition);\n            let compiledCondition = condition.map(child => precompRoot(child, depth, schema));\n\n\n\n            let compNest = new StateNode(root.id, BlockType.WHILE, [], false);\n            compNest.children = [compiledCondition, compiledWhile];\n\n            return compNest;\n\n        } else {\n            let myChildren = getChildren(root, schema);\n            console.log(\"my children before precompiling: \");\n            console.log(myChildren);\n            let compiledChildren = myChildren.map(child => precompRoot(child, depth, schema));\n            console.log(\"my children after precompiling: \");\n            console.log(compiledChildren);\n            let comp = new StateNode(root.id, root.blockType, root.constInputs, false);\n            comp.children = [compiledChildren];\n            console.log('value of comp\\'s children: ');\n            console.log(comp.children);\n\n            return comp;\n        }\n\n    }\n\n\n    /**\n     * Returns children of this node.\n     * @param root root node (not an input node)\n     * @param schema the schema that this node is in\n     */\n    function getChildren(root: CustomNode, schema: CustomSchema = mainSchema): CustomNode[] {\n        if (!schema.nodes.includes(root)) throw Error('This node is not in schema');\n\n        console.log(\"GETTING CHILDREN!\");\n        let children: CustomNode[] = [];\n        if (root.inputs == null) return [];\n\n\n        let portIds = root.inputs.map(port => port.id);\n        console.log(portIds);\n\n        portIds.sort();\n\n        console.log('port ids');\n        console.log(portIds);\n\n        if (portIds != null) {\n            let childrenOutputPorts = portIds.map(id=> schema.links.find(link=>link.input===id)?.output);\n            for (let portId of childrenOutputPorts) {\n                console.log('Found a child');\n                if(portId == null) throw new Error('Null port id!');\n                let nodeId = portId.substring(0, portId.indexOf(\"-output\"));\n                let child = schema.nodes.find(node => node.id === nodeId);\n                if (child != null) children.push(child);\n            }\n        }\n        return children;\n\n    }\n\n    /**\n     * Determines if the node is an input node. At the moment, only\n     * instances of InputNode are considered to be inputs.\n     * \n     * @param node the node\n     */\n    function isInput(node: CustomNode): boolean {\n        return node instanceof InputNode;\n    }\n\n\n\n    let precompiledStuff = getRoots(mainSchema).map(root => precompRoot(root));\n    console.log('Done precompiling! here\\'s what we have:');\n    console.log(precompiledStuff);\n    return precompiledStuff;\n\n}\n\n\n\nconst Precompiler = {\n    sortRoots,\n    precompile\n}\n\n\nexport default Precompiler;","import { SchemaSave } from './SchemaSave';\nimport { CustomSchema } from './../diagram/CustomSchema';\nimport { BlockType } from '../compiler/factory';\nimport DiagramIDE from \"../ide/DiagramIDE\";\nimport { CustomRender, IfRender, WhileRender } from '../diagram/renders';\n\nexport class SchemaSerializor {\n\n    public static serialize(): string {\n        let save: SchemaSave = {\n            ids: [],\n            schemas: [],\n            nodeIDStart: DiagramIDE.getID()\n        };\n\n        DiagramIDE.getIDE().validatedSchemas.forEach((value, key) => {\n            save.ids.push(key);\n            save.schemas.push(value);\n        })\n\n        return JSON.stringify(save);\n    }\n\n    public static deserialize(json: string): [Map<string, CustomSchema>, string] {\n        let save = JSON.parse(json) as SchemaSave;\n\n        let valSchemas = new Map();\n\n        for (let i = 0; i < save.ids.length; i++) {\n            let schema = save.schemas[i];\n\n            schema.nodes.forEach(node => {\n                switch (node.blockType) {\n                    case BlockType.IF:\n                        node.render = IfRender;\n                        break;\n                    case BlockType.WHILE:\n                        node.render = WhileRender;\n                        break;\n                    default:\n                        node.render = CustomRender;\n                }\n            });\n\n            valSchemas.set(save.ids[i], schema);\n        }\n\n        return [valSchemas, save.nodeIDStart];\n    }\n}","import React from 'react';\nimport { Button } from 'beautiful-react-ui';\n\n\nexport default function Information({loadBouncy, loadJoystick}) {\n    return (\n        <div className=\"info-panel\">\n            <h2>What is TeaBlocks?</h2>\n            <div className=\"info-block\">An educational mobile app project for teaching kids to code through a node-base visual programming language and lessons</div>\n            <h2>Instructions</h2>\n            <div className=\"info-block\">1. Select which node you want to add to the program</div>\n            <div className=\"info-block\">2. Click anywhere on the canvas to add the node</div>\n            <div className=\"info-block\">3. Connect node's by dragging the inputs to outputs</div>\n            <div className=\"info-block\">4. Press BUILD to compile your program, and press RUN to run it</div>\n            <h2>Examples</h2>\n            <div className=\"info-block\">Demo programs made in TeaBlocks </div>\n            <Button color=\"primary\" icon=\"upload\" onClick={loadBouncy} className=\"compile-btn\"> Load Bouncy Demo</Button>\n            <Button color=\"primary\" icon=\"upload\" onClick={loadJoystick} className=\"compile-btn\"> Load Joystick Demo</Button>\n        </div>\n    )\n}\n","import { useState, useEffect } from 'react';\nimport DiagramIDE from './DiagramIDE';\nimport { Button } from 'beautiful-react-ui';\nimport compile from '../compiler/Compiler';\nimport { Program } from '../compiler/Program';\nimport Runtime from '../runtime/Runtime';\nimport Precompiler from './Precompiler';\nimport { SchemaSerializor } from '../serializor/SchemaSerializor';\nimport { TeaBlocksError } from '../compiler/TeaBlocksError';\nimport '../styles/Ide.scss';\nimport ReactDOM from 'react-dom';\n\nimport bouncyProgram from '../demoContent/bouncy-program.json';\nimport joystickProgram from '../demoContent/joystick-program.json';\nimport Information from '../demoContent/Information';\n\nconst ideId = 'ide';\nconst emptyProgram = new Program([], new Map());\n\nlet canShowPopup = false;\n\n/**\n * The react component containing the IDE of the TeaBlocks app. This class\n * encapsulates DiagramIDE.\n */\nexport default function AppDiagram() {\n    const [program, setProgram] = useState<Program>(emptyProgram);\n    const [popOpen, setPopOpen] = useState(false);\n\n    useEffect(() => {\n        DiagramIDE.getIDE().renderDiagram();\n    }, []);\n\n    useEffect(() => {\n        let rtElem = document.getElementById('Runtime');\n        if (rtElem) {\n            console.log('UNMOUNTING RUNTIME');\n            ReactDOM.unmountComponentAtNode(rtElem);\n        }\n\n        if (program !== emptyProgram) {\n            console.log('MOUNTING RUNTIME');\n            ReactDOM.render((\n                <Runtime program={program} />\n            ), document.getElementById('Runtime'));\n        }\n\n        return () => {\n            console.log('Cleanup?')\n            program.stop();\n        }\n    }, [program])\n\n    function build() {\n        console.log('Button compile and run');\n        DiagramIDE.getIDE().unflagNodes();\n\n        let precomp = Precompiler.precompile(DiagramIDE.getIDE().validatedSchemas);\n        canShowPopup = true;\n        compile(precomp).then(prog => {\n            prog.errorNotify = errorNotify;\n            setProgram(prog);\n        }).catch(err => {\n            console.error(err);\n        })\n    }\n\n    function runProg() {\n        program.varEnv.set('&joy-joystick', { x: 0, y: 0 }); //! remove later\n\n        console.log('Run Program');\n\n        try {\n            program.run();\n        } catch (err) {\n            if (err instanceof TeaBlocksError) {\n                console.error(err);\n                DiagramIDE.getIDE().flagNodes(err.id);\n            } else {\n                throw err;\n            }\n        }\n    }\n\n    function errorNotify(message: string, ...nodeId: string[]): void {\n        DiagramIDE.getIDE().flagNodes(...nodeId);\n        DiagramIDE.getIDE().redrawDiagram();\n    }\n\n    function goHome() {\n        DiagramIDE.getIDE().setDisplaySchemaId('main');\n    }\n\n    // function load() {\n    //     let json = prompt('Paste the JSON for validatedSchemas:', '');\n    //     let [val, nID] = SchemaSerializor.deserialize(json ? json : '');\n    //     DiagramIDE.getIDE().loadSchemas(val, nID);\n    // }\n\n    // ! temporary for demo files\n    function loadBouncy() {\n        let stringified = JSON.stringify(bouncyProgram);\n        let [val, nID] = SchemaSerializor.deserialize(stringified ? stringified : '');\n        DiagramIDE.getIDE().loadSchemas(val, nID);\n    }\n\n    function loadJoystick() {\n        let stringified = JSON.stringify(joystickProgram);\n        let [val, nID] = SchemaSerializor.deserialize(stringified ? stringified : '');\n        DiagramIDE.getIDE().loadSchemas(val, nID);\n    }\n\n    function togglePopup() {\n        setPopOpen(!popOpen);\n    }\n\n\n\n    return (\n        <div className=\"grid-container\">\n            <div className=\"Ide\">\n                <div id={ideId} />\n                <Button color=\"primary\" icon=\"home\" onClick={goHome} className=\"compile-btn\"> Go to Main</Button>\n                <Button color=\"primary\" icon=\"hammer\" onClick={() => { build() }} className=\"compile-btn\"> Build</Button>\n                <Button color=\"primary\" icon=\"play\" onClick={() => runProg()} className=\"compile-btn\"> Run</Button>\n                <Button color=\"primary\" icon=\"stop\" onClick={program.stop} className=\"compile-btn\"> Stop</Button>\n                {canShowPopup && <Button color=\"primary\" icon=\"question\" onClick={togglePopup} className=\"compile-btn help\">Help</Button>}\n                {/* <Button color=\"primary\" icon=\"save\" onClick={() => { console.log(SchemaSerializor.serialize()) }} className=\"compile-btn\"> Save</Button> */}\n                {/* <Button color=\"primary\" icon=\"upload\" onClick={load} className=\"compile-btn\"> Load</Button> */}\n            </div>\n            <div className=\"Runtime\" id=\"Runtime\">\n                <Information loadBouncy={loadBouncy} loadJoystick={loadJoystick} />\n            </div>\n            {popOpen && <div className=\"info-popup\">\n                <Information loadBouncy={loadBouncy} loadJoystick={loadJoystick} />\n                <button onClick={togglePopup} className=\"close-btn\">X</button>\n            </div>}\n            \n        </div>\n    )\n}\n","import React from 'react';\nimport './styles/App.scss';\nimport AppDiagram from './ide/AppDiagram';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h1>TeaBlocks Demo (WIP)</h1>\n      <AppDiagram />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","import { ShapeColor } from './ShapeColor';\nimport { ShapeType } from \"./ShapeType\";\n\nexport class Shape {\n    shapeName: string;\n    posX: number;\n    posY: number;\n    scaleX: number;\n    scaleY: number;\n    rot: number;\n    type: ShapeType;\n    color: ShapeColor;\n\n\n    /**\n     * Constructor\n     * @param shapeName shape name.\n     * @param type type of shape enum.\n     * @param color the color of shape enum.\n     * @param posX initial x positon.\n     * @param posY initial y positon.\n     * @param scaleX initial x scale.\n     * @param scaleY initial y scale.\n     * @param rot rotation in degrees.\n     */\n    constructor(shapeName: string,\n        type: ShapeType,\n        color: ShapeColor,\n        posX: number,\n        posY: number,\n        scaleX: number,\n        scaleY: number,\n        rot: number) {\n        this.shapeName = shapeName;\n        this.posX = posX;\n        this.posY = posY;\n        this.scaleX = scaleX;\n        this.scaleY = scaleY;\n        this.rot = rot;\n        this.type = type;\n        this.color = color;\n    }\n\n\n\n}","import { NodeData } from './NodeData';\nimport { BlockType } from './../compiler/factory/BlockType';\nimport { Node, NodeCoordinates, Port } from 'beautiful-react-diagrams/@types/DiagramSchema';\nimport { ElementType, ReactNode } from 'react';\nimport { CustomNode } from './CustomNode';\nimport { GuranteedRoot } from './GuranteedRoot';\nimport DiagramIDE from '../ide/DiagramIDE';\n\n\nexport class OutputNode extends GuranteedRoot implements CustomNode {\n    id: string;\n    coordinates: NodeCoordinates;\n    content: ReactNode;\n    inputs: Port[];\n    data: NodeData;\n    render: (props: Omit<Node<any>, 'coordinates'>) => ElementType | ReactNode;\n    blockType: BlockType;\n    constInputs: any[];\n\n    /**\n     * \n     * @param content content of this node\n     * @param coordinates inital coordinates of the node\n     * @param numInputs the number of input ports this node should have\n     * @param blockType the type of the assembly block created (for phasing out assConstructor)\n     * @param constInputs constant inputs that assembly block takes.\n     * @param data data of the node (any object; should contain assConstructor)\n     * @param render renderer used to render\n     * ! ^ data is kinda weird. need to figure out how to replace it with more concrete/safe types.\n     */\n    constructor(content: ReactNode,\n        coordinates: NodeCoordinates,\n        numInputs: number,\n        blockType: BlockType,\n        constInputs: any[],\n        data: NodeData,\n        render: (props: Omit<Node<any>, 'coordinates'>) => ElementType | ReactNode) {\n        super();\n        this.id = DiagramIDE.getID()\n        this.coordinates = coordinates;\n        this.content = content;\n        this.data = data;\n        this.render = render;\n\n        this.blockType = blockType;\n        this.constInputs = constInputs;\n\n        console.log('Outputs id: ' + this.id);\n\n        this.inputs = [];\n        for (let i = 0; i < numInputs; i++) {\n            let portId: string = `${this.id}-input-${i}`\n            console.log('port id: ' + portId);\n            let port: Port = { id: portId };\n            this.inputs.push(port);\n        }\n    }\n\n\n\n}","import { ControlType } from './ControlType';\n\n/**\n * A data type (bean) for a UI Input Element.\n */\nexport class ControlElement {\n    displayName: string;\n    x: number;\n    y: number;\n    type: ControlType;\n\n    /**\n     * Constructor\n     * @param displayName the display name of the shape (what the user specifies).\n     * @param x x position\n     * @param y y position\n     * @param type type of control\n     */\n    constructor(displayName:string,x: number, y: number, type: ControlType) {\n        this.displayName = displayName\n        this.x = x;\n        this.y = y;\n        this.type = type;\n    }\n}","import { ControlElement } from './ControlElement';\nimport { TeaBlocksError } from './../../TeaBlocksError';\nimport { ControlType } from './ControlType';\nimport { VoidBlock } from \"../VoidBlock\";\nimport { ReturnBlock } from '../ReturnBlock';\n\n/**\n * Like the MakeShapeBlock. Creates and assigns an a ControlElement object to \n * $elemName in the varEnv. Does not draw the variable itself.\n */\nexport class MakeControlElementBlock extends VoidBlock {\n    x: ReturnBlock;\n    y: ReturnBlock;\n    elemName: string;\n    type: ControlType;\n\n    /**\n     * Constructor.\n     * @param id id of statenode\n     * @param type the type of ui element\n     * @param elemName the display name of the ui element (what user specifies)\n     * @param inputs inputs[0] is x; input[1] is y\n     */\n    constructor(id: string, type: ControlType, elemName: string, inputs: ReturnBlock[]) {\n        super(id);\n        this.type = type;\n        this.elemName = elemName;\n        this.x = inputs[0];\n        this.y = inputs[1];\n    }\n\n\n    *evalBlock(varEnv: Map<string, any>) {\n        let x = Number(this.x.evalBlock(varEnv));\n        let y = Number(this.y.evalBlock(varEnv));\n\n        if (isNaN(x) || isNaN(y)) throw new TeaBlocksError('Position must be a number', this.id);\n\n        let elem = new ControlElement(this.elemName, x, y, this.type);\n\n        varEnv.set('$' + this.elemName, elem);\n        yield;\n    }\n\n}","import { ReturnBlock } from \"../ReturnBlock\";\nimport { VoidBlock } from \"../VoidBlock\";\n\n/**\n * Internal use.\n */\nexport class ConsoleLogBlock extends VoidBlock {\n    input;\n\n    /**\n     * Constructor\n     * @param input array of return blocks being printed\n     */\n    constructor(id: string, input: ReturnBlock[]) {\n        super(id)\n        console.log(\"this is the input\", input)\n        this.input = input;\n    }\n\n    *evalBlock(varEnv: Map<string, any>){\n        this.input.forEach(inp => {\n            let val = inp.evalBlock(varEnv);\n            console.log(val);\n        });\n        yield;\n\n    }\n}","import { ReturnBlock } from \"../../../ReturnBlock\";\n\n/**\n * \"Equal\" block.\n */\nexport class EQBlock extends ReturnBlock {\n    leftSide;\n    rightSide;\n\n    /**\n     * Constructor\n     * @param inputs the inputs of comparison (inputs[0] is left; inputs[1] is right)\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.leftSide = inputs[0];\n        this.rightSide = inputs[1];\n    }\n\n    /**\n     * Compares left and right side, returns true if \"leftSide == rightSide\"\n     * @param varEnv the variable envornment\n     */\n    evalBlock(varEnv: Map<string, any>): boolean {\n        let ls = this.leftSide.evalBlock(varEnv);\n        let rs = this.rightSide.evalBlock(varEnv);\n\n        // eslint-disable-next-line eqeqeq\n        return ls == rs;\n    }\n}","import { ReturnBlock } from \"../../../ReturnBlock\";\n\n/**\n * \"Greater than or equal\" block.\n */\nexport class GEQBlock extends ReturnBlock {\n    leftSide;\n    rightSide;\n\n    /**\n     * Constructor\n     * @param inputs the inputs of comparison (inputs[0] is left; inputs[1] is right)\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.leftSide = inputs[0];\n        this.rightSide = inputs[1];\n    }\n    /**\n     * Compares left and right side, returns true if \"leftSide >= rightSide\"\n     * @param varEnv the variable envornment\n     */\n    evalBlock(varEnv: Map<string, any>) {\n        let ls = this.leftSide.evalBlock(varEnv);\n        let rs = this.rightSide.evalBlock(varEnv);\n\n        return ls >= rs;\n    }\n}","import { ReturnBlock } from \"../../../ReturnBlock\";\n\n/**\n * \"Greater than\" block.\n */\nexport class GTBlock extends ReturnBlock {\n    leftSide;\n    rightSide;\n\n    /**\n     * Constructor\n     * @param inputs the inputs of comparison (inputs[0] is left; inputs[1] is right)\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.leftSide = inputs[0];\n        this.rightSide = inputs[1];\n    }\n\n    /**\n     * Compares left and right side, returns true if \"leftSide > rightSide\"\n     * @param varEnv the variable envornment\n     */\n    evalBlock(varEnv: any) {\n        let ls = this.leftSide.evalBlock(varEnv);\n        let rs = this.rightSide.evalBlock(varEnv);\n\n        return ls > rs;\n    }\n}","import { ReturnBlock } from \"../../../ReturnBlock\";\n\n/**\n * \"Less than or equal\" block.\n */\nexport class LEQBlock extends ReturnBlock {\n    leftSide;\n    rightSide;\n\n   /**\n     * Constructor\n     * @param inputs the inputs of comparison (inputs[0] is left; inputs[1] is right)\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.leftSide = inputs[0];\n        this.rightSide = inputs[1];\n    }\n\n    /**\n     * Compares left and right side, returns true if \"leftSide <= rightSide\"\n     * @param varEnv the variable envornment\n     */\n    evalBlock(varEnv: Map<string, any>) {\n        let ls = this.leftSide.evalBlock(varEnv);\n        let rs = this.rightSide.evalBlock(varEnv);\n\n        return ls <= rs;\n    }\n}","import { ReturnBlock } from \"../../../ReturnBlock\";\n\n/**\n * \"Less than\" block.\n */\nexport class LTBlock extends ReturnBlock {\n    leftSide;\n    rightSide;\n\n    /**\n     * Constructor\n     * @param inputs the inputs of comparison (inputs[0] is left; inputs[1] is right)\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id);\n        this.leftSide = inputs[0];\n        this.rightSide = inputs[1];\n    }\n\n    /**\n     * Compares left and right side, returns true if \"leftSide < rightSide\"\n     * @param varEnv the variable envornment\n     */\n    evalBlock(varEnv: Map<string, any>) {\n        let ls = this.leftSide.evalBlock(varEnv);\n        let rs = this.rightSide.evalBlock(varEnv);\n\n        return ls < rs;\n    }\n}","import { ReturnBlock } from \"../../../ReturnBlock\";\n\n/**\n * Boolean AND operation\n */\nexport class ANDBlock extends ReturnBlock {\n    inputs;\n\n    /**\n     * Constructor\n     * @param inputs the inputs being processed\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.inputs = inputs;\n    }\n\n    /**\n     * Performs boolean AND operation on inputs\n     * @param varEnv the variable envornment\n     */\n    evalBlock(varEnv: Map<string, any>): boolean {\n        for(let inp of this.inputs){\n            let val = Boolean(inp.evalBlock(varEnv));\n            if (!val){\n                return false;\n            }\n        }\n\n        return true;\n    }\n}","import { ReturnBlock } from \"../../../ReturnBlock\";\n\n/**\n * The boolean NOT\n */\nexport class NOTBlock extends ReturnBlock {\n    bool;\n\n    /**\n     * Constructor\n     * @param inputs the inputs (only cares about inputs[0]).\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.bool = inputs[0];\n    }\n\n    /**\n     * Performs boolean NOT operation on input.\n     * @param varEnv the variable envornment\n     */\n    evalBlock(varEnv: Map<string, any>): boolean {\n        let input = Boolean(this.bool.evalBlock(varEnv));\n        return !input;\n    }\n}","import { ReturnBlock } from \"../../../ReturnBlock\";\n\n/**\n * Boolean OR operation\n */\nexport class ORBlock extends ReturnBlock {\n    inputs;\n\n    /**\n     * Constructor\n     * @param inputs the inputs being processed\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.inputs = inputs;\n    }\n\n    /**\n     * Performs boolean OR operation on inputs\n     * @param {Map} varEnv the variable envornment\n     */\n    evalBlock(varEnv: Map<string, any>): boolean {\n        for (let inp of this.inputs) {\n            let val = Boolean(inp.evalBlock(varEnv));\n            if (val) return true;\n        }\n        return false;\n    }\n}","import { TeaBlocksError } from './../../../TeaBlocksError';\nimport { ReturnBlock } from \"../../ReturnBlock\";\n\n/**\n * Math division block. Does input[0]/input[1]/input[2]... if all values after input[0] are non zero.\n */\nexport class DivisionBlock extends ReturnBlock {\n    inputs;\n\n    /**\n     * Constructor\n     * @param inputs the inputs.\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.inputs = inputs;\n    }\n\n    /**\n     * Evaluates the expression.\n     * @param varEnv the variable environment\n     */\n    evalBlock(varEnv: Map<string, any>): number {\n        let rVal = Number(this.inputs[0].evalBlock(varEnv));\n        if (this.inputs.length === 1 || rVal === 0 || isNaN(rVal)) {\n            return rVal;\n        }\n\n        this.inputs.slice(1).forEach(inp => {\n            let num = Number(inp.evalBlock(varEnv));\n            if(isNaN(num)) throw new TeaBlocksError('Input is not a number', this.id);\n\n            if (num === 0) {\n                throw new TeaBlocksError('Can\\'t divide by zero.', this.id);\n            }\n            rVal /= num;\n        });\n\n        return rVal;\n    }\n}\n","import { TeaBlocksError } from './../../../TeaBlocksError';\nimport { ReturnBlock } from \"../../ReturnBlock\";\n\n/**\n * Math exponent block. Does input[0]^input[1]^input[2]...\n */\nexport class ExponentBlock extends ReturnBlock {\n    inputs;\n\n    /**\n     * Constructor\n     * @param inputs the left operand\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.inputs = inputs;\n    }\n\n    /**\n     * Evaluates the expression\n     * @param {Map} varEnv variable environment\n     */\n    evalBlock(varEnv: Map<string, any>): number {\n        let firstNum = Number(this.inputs[0].evalBlock(varEnv));\n\n        if (isNaN(firstNum)) throw new TeaBlocksError('Inputs must be numbers', this.id);\n\n        if (this.inputs.length === 1 || firstNum === 1 || firstNum === 0) return firstNum;\n\n        this.inputs.slice(1).forEach(inp => {\n            let pow = Number(inp.evalBlock(varEnv));\n            if (isNaN(pow)) throw new TeaBlocksError('Inputs must be numbers', this.id);\n            if (pow === 0) return 1;\n            firstNum = Math.pow(firstNum, pow);\n        });\n\n        return firstNum;\n    }\n}\n","import { TeaBlocksError } from './../../../TeaBlocksError';\nimport { ReturnBlock } from \"../../ReturnBlock\";\n\n\n/**\n * Math modulo block. Performs inputs[0]%inputs[1]%inputs[2]...\n */\nexport class ModuloBlock extends ReturnBlock {\n    inputs;\n\n    /**\n     * Constructor\n     * @param inputs the operands\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.inputs = inputs;\n    }\n\n    /**\n     * Evaluates the expression\n     * @param varEnv variable environment\n     */\n    evalBlock(varEnv: Map<string, any>): number {\n        let num = Number(this.inputs[0].evalBlock(varEnv));\n\n        if (this.inputs.length === 1) return num;\n        if (isNaN(num)) throw new TeaBlocksError('Inputs Must be Number', this.id);\n\n        this.inputs.slice(1).forEach(inp => {\n            let val = Number(inp.evalBlock(varEnv));\n            if (isNaN(val)) throw new TeaBlocksError('Inputs must be numbers', this.id);\n            num %= val;\n        })\n\n        return num;\n    }\n}\n","import { TeaBlocksError } from './../../../TeaBlocksError';\nimport { ReturnBlock } from \"../../ReturnBlock\";\n\n/**\n * Math multiplication block. Multiplies values together.\n */\nexport class ProductBlock extends ReturnBlock {\n    operands;\n    \n    /**\n     * Constructor\n     * @param  operands operands of multiplication\n     */\n    constructor(id: string, operands: ReturnBlock[]){\n        super(id)\n        this.operands = operands;\n    }\n\n    /**\n     * Evaluates the expression\n     * @param varEnv variable environment\n     * @returns all operands multiplied together (1 if there are no operands)\n     */\n    evalBlock(varEnv: Map<string, any>): number{\n        let ans = 1;\n\n        for(let op of this.operands){\n            let val = Number(op.evalBlock(varEnv));\n            if(isNaN(val)) throw new TeaBlocksError(\"Input not a number\", this.id);\n            if (val === 0) return 0;\n\n            ans *= val;\n        }\n\n        return ans;\n    }    \n}\n","import { TeaBlocksError } from './../../../TeaBlocksError';\nimport { ReturnBlock } from '../../ReturnBlock';\n/**\n * Math subtraction block. Does inputs[0]-inputs[1]-inputs[2]-inputs[3]...\n */\nexport class SubtractBlock extends ReturnBlock {\n    inputs;\n\n    /**\n     * Constructor\n     * @param {ReturnBlock} inputs operands\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.inputs = inputs;\n    }\n\n    /**\n     * Evaluates the expression\n     * @param {Map} varEnv variable environment\n     * @returns left - (right_1 + right_2 + ...)\n     */\n    evalBlock(varEnv: Map<string, any>): number {\n        let ans = Number(this.inputs[0].evalBlock(varEnv));\n        if (isNaN(ans)) throw new TeaBlocksError(\"Input not a number\", this.id);\n\n        for (let op of this.inputs.slice(1)) {\n            let val = Number(op.evalBlock(varEnv));\n            if (isNaN(val)) throw new TeaBlocksError(\"Input not a number\", this.id);\n            ans -= val;\n        }\n        return ans;\n    }\n}\n","import { ReturnBlock } from \"../../ReturnBlock\";\n\n/**\n * Math addition block. Adds left and right values together.\n */\nexport class SumBlock extends ReturnBlock {\n    operands\n\n    /**\n     * Constructor\n     * @param operands \n     */\n    constructor(id: string, operands: ReturnBlock[]) {\n        super(id)\n        this.operands = operands;\n    }\n\n    /**\n     * Evaluates the expression\n     * @param {Map} varEnv variable environment\n     * @returns the sum of all operands.\n     */\n    evalBlock(varEnv: Map<string, any>) {\n        let ans: number | string = '';\n        let stringMode = false;\n\n        for (let op of this.operands) {\n            console.log(op);\n            let val = op.evalBlock(varEnv);\n\n            let numVal = Number(val);\n            stringMode = stringMode || isNaN(numVal);\n\n            if (stringMode) {\n                ans = String(ans) + String(val);\n            } else {\n                ans = Number(ans) + numVal;\n\n            }\n        }\n\n        return ans;\n    }\n}\n","import { ReturnBlock } from \"../ReturnBlock\";\n\n/**\n * Assembly block for ternary statement (condition ? tValue : fValue)\n */\nexport class TernaryBlock extends ReturnBlock {\n\n    condition: ReturnBlock;\n    tValue: ReturnBlock;\n    fValue: ReturnBlock;\n\n    /**\n     * Constructor\n     * @param inputs the inputs. Condition is index 0, true value is index 1, false value is index 2\n     */\n    constructor(id: string, inputs: ReturnBlock[]) {\n        super(id)\n        this.condition = inputs[0];\n        this.tValue = inputs[1];\n        this.fValue = inputs[2];\n    }\n\n    /**\n     * Evaluates the expression.\n     * @param varEnv variable environment\n     * @returns the value of 'condition ? tValue : fValue' expression\n     */\n    evalBlock(varEnv: Map<string, any>): any {\n        let condition = Boolean(this.condition.evalBlock(varEnv));\n\n        let value;\n        if (condition) {\n            value = this.tValue.evalBlock(varEnv);\n        } else {\n            value = this.fValue.evalBlock(varEnv);\n        }\n\n        return value;\n    }\n}","import { TeaBlocksError } from './../../TeaBlocksError';\nimport { ReturnBlock } from '../ReturnBlock';\nimport { VoidBlock } from '../VoidBlock';\n\n/**\n * Block for creating/modifying a variable. Assigns a value to some variable name in variable environment.\n */\nexport class VarAssignBlock extends VoidBlock {\n    varName: string;\n    value: ReturnBlock;\n\n    /**\n     * Constructor (doesn't create the variable itself tho)\n     * \n     * @param varName variable name\n     * @param value value being assigned to the variable (only uses value[0])\n     */\n    constructor(id: string, varName: string, value: ReturnBlock[]) {\n        super(id)\n        this.varName = varName;\n        this.value = value[0];\n    }\n\n    /**\n     * Evaluates the variable assignment\n     * @param varEnv the variable envornment\n     */\n    *evalBlock(varEnv: Map<string, any>) {\n        if (this.varName.includes('$') || this.varName.includes('&')) {\n            throw new TeaBlocksError('Variable name contains illegal character', this.id);\n        }\n        let evalValue = this.value.evalBlock(varEnv);\n        varEnv.set(this.varName, evalValue);\n        yield;\n    }\n}\n","import { InternalCompilerError } from './../../InternalCompilerError';\nimport { ReturnBlock } from \"../ReturnBlock\";\nimport { VarAssignBlock } from \"../variable/VarAssignBlock\";\nimport { VoidBlock } from \"../VoidBlock\";\n\n/**\n * A block to represent a FOR loop (;; style). Creates incrementor variable, executes nodes while \n * the condition holds, incrementing the incrementor variable by some value after each iteration.\n */\nexport class FORBlock extends VoidBlock {\n    counterName;\n    initialValue;\n    condition;\n    incrementValue;\n    nodes;\n    len;\n\n    /**\n     * Constructor\n     * @param counterName name of counter variable\n     * @param initialValue (number) counter initial value (0th index)\n     * @param condition (boolean) condition for running (0th index)\n     * @param incrementValue (number) value by which to increment (positive or negative; 0th index)\n     * @param nodes array of nodes to execute while condition is true. These nodes are roots of trees that\n     * need to be executed conditionaly (loop), hence they must be VoidBlocks.\n     */\n    constructor(id: string, counterName: string,\n        initialValue: ReturnBlock[],\n        condition: ReturnBlock[],\n        incrementValue: ReturnBlock[],\n        nodes: VoidBlock[]) {\n        super(id)\n        this.counterName = counterName;\n        this.initialValue = initialValue[0];\n        this.condition = condition[0];\n        this.incrementValue = incrementValue[0];\n        this.nodes = nodes;\n\n        this.len = 0;\n        for (let b of nodes) {\n            this.len += b.getLength();\n        }\n    }\n\n    *evalBlock(varEnv: Map<string, any>) {\n        // using VarAssignBlock to create/assign the counter variable\n        let countVarAssign = new VarAssignBlock(this.id, this.counterName, [this.initialValue]);\n        countVarAssign.evalBlock(varEnv);\n\n        while (true) {\n            // condition\n            let comp = Boolean(this.condition.evalBlock(varEnv));\n\n            if (!comp) return; // stop if condition false\n\n            // executing nodes\n            for (let node of this.nodes) {\n                if (!(node instanceof VoidBlock)) throw new InternalCompilerError('Loop body must be void');\n\n                let gen = node.evalBlock(varEnv);\n                let status;\n\n                do {\n                    status = gen.next();\n                    yield;\n                } while (!status.done);\n            }\n\n            let incrValue = this.incrementValue.evalBlock(varEnv);\n            varEnv.set(this.counterName, varEnv.get(this.counterName) + incrValue);\n        }\n    }\n\n    getLength() {\n        return this.len;\n    }\n}","import { InternalCompilerError } from './../../InternalCompilerError';\nimport { ReturnBlock } from \"../ReturnBlock\";\nimport { ANDBlock } from \"../returnBlocks/boolean/operators/ANDBlock\";\nimport { VoidBlock } from \"../VoidBlock\";\n\nexport class IFBlock extends VoidBlock {\n    condition; // the condition\n    then; // what is executed if condition is true\n    otherwise; // what is executed otherwise   \n    len; //length\n\n    /**\n     * Constructor for an IF block\n     * @param condition condition block of if statement (boolean). If more than one conditions\n     * are passed in, the AND operation is performed.\n     * @param then block evaluated if condition is true\n     * @param otherwise block evaluated if condition is false\n     */\n    constructor(id: string, condition: ReturnBlock[],\n        then: VoidBlock[],\n        otherwise: VoidBlock[]) {\n        super(id)\n        this.condition = condition;\n        this.then = then;\n        this.otherwise = otherwise;\n\n        let ifLen = 0, elseLen = 0;\n\n        for (let block of then) {\n            ifLen += block.getLength();\n        }\n\n        for(let block of otherwise){\n            elseLen += block.getLength();\n        }\n\n        this.len = Math.max(ifLen, elseLen);\n    }\n\n    /**\n     * Evaluates IF block. If condition is boolean and true, \"then\" block are evaluated, if condition is boolean\n     * and false, \"otherwise\" blocks are executed. If condition is not boolean a TypeError is thrown. \n     * @param varEnv the variable envornment\n     */\n    *evalBlock(varEnv: Map<string, any>) {\n        // evaluating the condition\n        let andInpsConds = this.condition;\n        const andBlock: ANDBlock = new ANDBlock(this.id, andInpsConds);\n        const cond = andBlock.evalBlock(varEnv);\n        const runBlocks = cond ? this.then : this.otherwise;\n\n        for (let block of runBlocks) {\n            if (!(block instanceof VoidBlock)) throw new InternalCompilerError('Loop body must be void');\n\n            let gen = block.evalBlock(varEnv);\n            let status;\n\n            do {\n                status = gen.next();\n                yield;\n            } while (!status.done);\n\n        }\n\n        return;\n    }\n\n    /**\n     * Returns the maximimum minimum execution time for the if statement. (max between if and else sides' minimum\n     * execution length).\n     */\n    getLength(){\n        return this.len;\n    }\n}","import { InternalCompilerError } from './../../InternalCompilerError';\nimport { ReturnBlock } from \"../ReturnBlock\";\nimport { ANDBlock } from \"../returnBlocks/boolean/operators/ANDBlock\";\nimport { VoidBlock } from \"../VoidBlock\";\n\nexport class WHILEBlock extends VoidBlock {\n    conditions;\n    blocks;\n    len: number;\n\n    /**\n     * Constructor\n     * @param conditions the number of iterations (boolean)\n     * @param blocks array of void blocks to execute while condition is true\n     */\n    constructor(id: string, conditions: ReturnBlock[], blocks: VoidBlock[]) {\n        super(id)\n        this.conditions = conditions;\n        this.blocks = blocks;\n\n        this.len = 0;\n        for (let b of blocks) {\n            this.len += b.getLength();\n        }\n    }\n\n\n    /**\n     * If the condition evaluates to true, all blocks are ran. The cycle is repeated untill condition evaluates to false.\n     * @param varEnv the variable envornment\n     */\n    *evalBlock(varEnv: Map<string, any>) {\n        while (true) {\n            let andBlock: ANDBlock = new ANDBlock(this.id, this.conditions);\n            let cond = andBlock.evalBlock(varEnv);\n\n            if (!cond) return;\n\n            for (let block of this.blocks) {\n                if (!(block instanceof VoidBlock)) throw new InternalCompilerError('Loop body must be void');\n\n                let gen = block.evalBlock(varEnv);\n\n                let status;\n                do {\n                    status = gen.next();\n                    yield;\n                } while (!status.done)\n\n            }\n        }\n    }\n\n    /**\n     * Returns the minimum number of steps required to complete a single iteration of the loop.\n     */\n    getLength() {\n        return this.len;\n    }\n}\n","import { ReturnBlock } from \"../ReturnBlock\";\n\n/**\n * A constant value block (essentially a primitive). Takes some value that does not change\n * like a string or a number.\n */\nexport class ConstBlock extends ReturnBlock {\n    value;\n\n    /**\n     * Constructor\n     * @param value value of the constant\n     */\n    constructor(id: string, value: any){\n        super(id)\n        this.value = value;\n    }\n\n    /**\n     * Returns the value of the const block.\n     * @param varEnv variable environment\n     */\n    evalBlock(varEnv: Map<string, any>): any{\n        return this.value;\n    }\n}","import { ConstBlock } from './ConstBlock';\nimport { VarAssignBlock } from './VarAssignBlock';\n\n/**\n * A variable creation block. Creates an empty array.\n */\nexport class ArrayCreateBlock extends VarAssignBlock {\n\n    /**\n     * Constructor\n     * @param id the id of statenode\n     * @param varName name of the array\n     */\n    constructor(id: string, varName: string) {\n        super(id, varName, [new ConstBlock(id, [])]);\n    }\n\n}","import { TeaBlocksError } from './../../TeaBlocksError';\nimport { ReturnBlock } from \"../ReturnBlock\";\n\n/**\n * Block for retrieving a value of an array at a specific index.\n */\nexport class ArrayGetIndex extends ReturnBlock {\n    index: ReturnBlock;\n    arrName: string;\n\n    /**\n     * Constructor\n     * @param id id of state node\n     * @param arrName name of array\n     * @param inputs index is inputs[0]\n     */\n    constructor(id: string, arrName: string, inputs: ReturnBlock[]) {\n        super(id);\n        this.arrName = arrName;\n        this.index = inputs[0];\n    }\n\n\n    /**\n     * Retrieves the value of the array at provided index.\n     * @param varEnv variable environment\n     */\n    evalBlock(varEnv: Map<string, any>) {\n        let arr = varEnv.get(this.arrName);\n        if (arr == null) throw new TeaBlocksError('Array does not exist', this.id);\n\n        let index = Number(this.index.evalBlock(varEnv));\n        if (isNaN(index)) throw new TeaBlocksError('Index is not a number', this.id);\n\n        let val = arr[index];\n\n        if (val == null) throw new TeaBlocksError(`Nothing at index ${index}`, this.id);\n\n        return val;\n    }\n\n\n}","import { TeaBlocksError } from './../../TeaBlocksError';\nimport { ReturnBlock } from \"../ReturnBlock\";\nimport { VoidBlock } from \"../VoidBlock\";\n\nexport class ArraySetIndex extends VoidBlock {\n    arrName: string;\n    index: ReturnBlock;\n    value: ReturnBlock;\n\n    /**\n     * Constructor\n     * @param id the id of state node\n     * @param arrName name of array\n     * @param inputs inputs[0] is the index; inputs[1] is the value\n     */\n    constructor(id: string, arrName: string, inputs: ReturnBlock[]) {\n        super(id);\n        this.arrName = arrName;\n        this.index = inputs[0];\n        this.value = inputs[1];\n    }\n\n\n    /**\n     * Assigns the value to the index of this array. Computes the value being assigned\n     * before the index.\n     * \n     * @param varEnv variable environment\n     */\n    *evalBlock(varEnv: Map<string, any>) {\n        let value = this.value.evalBlock(this.value.evalBlock(varEnv));\n\n        let arr = varEnv.get(this.arrName);\n        if (arr == null) throw new TeaBlocksError('Array does not exist', this.id);\n\n        let index = Number(this.index.evalBlock(varEnv));\n        if (isNaN(index)) throw new TeaBlocksError('Index is not a number', this.id);\n\n        arr[index] = value;\n\n        varEnv.set(this.arrName, arr);\n\n        yield;\n    }\n\n}","import { VoidBlock } from \"../VoidBlock\";\n\n/**\n * Block for deleting a variable from the variable environment\n */\nexport class VarDeleteBlock extends VoidBlock{\n    varName: string;\n\n    /**\n     * Constructor\n     * @param varName variable name\n     */\n    constructor(id: string, varName:string){\n        super(id)\n        this.varName = varName;\n    }\n\n    /**\n     * Deletes varName from variable environment if it exists.\n     * @param varEnv variable environment\n     */\n    *evalBlock(varEnv:Map<string, any>){\n        if(varEnv.has(this.varName)){\n            varEnv.delete(this.varName);\n        }\n        yield;\n    }\n}","import { TeaBlocksError } from './../../TeaBlocksError';\nimport { ReturnBlock } from \"../ReturnBlock\";\n\n/**\n * Block for retrieving the value of a variable from the variable\n * environment based on the variable name.\n */\nexport class VarRetrieveBlock extends ReturnBlock {\n    varName: string;\n\n    /**\n     * Constructor.\n     * @param varName variable name\n     */\n    constructor(id: string, varName: string) {\n        super(id)\n        this.varName = varName;\n    }\n\n    /**\n     * Retrives the value under varName from variable environment if that variable exists.\n     * @param varEnv the variable envornment\n     */\n    evalBlock(varEnv: Map<string, any>): void {\n        if (this.varName.includes('$') || this.varName.includes('&')) {\n            throw new TeaBlocksError('Variable name contains illegal character', this.id);\n        }\n        \n        if (!varEnv.has(this.varName)) {\n            throw new TeaBlocksError(\"Variable \" + this.varName + \" does not exist\", this.id);\n        }\n        return varEnv.get(this.varName);\n    }\n}","import { JoyXStatusBlock, JoyYStatusBlock, ButtonStatusBlock } from \"../assemblyBlocks/inputBlocks\";\nimport { MakeControlElementBlock } from \"../assemblyBlocks/inputBlocks/MakeControlElementBlock\";\nimport { ConsoleLogBlock } from \"../assemblyBlocks/outputBlocks/ConsoleLogBlock\";\nimport { EQBlock, GEQBlock, GTBlock, LTBlock, LEQBlock } from \"../assemblyBlocks/returnBlocks/boolean/comparison\";\nimport { ANDBlock, NOTBlock, ORBlock } from \"../assemblyBlocks/returnBlocks/boolean/operators\";\nimport { DivisionBlock, ExponentBlock, ModuloBlock, ProductBlock, SubtractBlock, SumBlock } from \"../assemblyBlocks/returnBlocks/math\";\nimport { TernaryBlock } from \"../assemblyBlocks/returnBlocks/TernaryBlock\";\nimport { GetXBlock, GetYBlock, MoveBlock, RotateBlock, ScaleBlock } from \"../assemblyBlocks/shape\";\nimport { GetShapeBlock } from \"../assemblyBlocks/shape/GetShapeBlock\";\nimport { MakeShapeBlock } from \"../assemblyBlocks/shape/MakeShapeBlock\";\nimport { WHILEBlock, IFBlock, FORBlock } from \"../assemblyBlocks/specialBlocks\";\nimport { ArrayGetIndex, ArraySetIndex, ConstBlock, VarAssignBlock, VarDeleteBlock, VarRetrieveBlock } from \"../assemblyBlocks/variable\";\nimport { ArrayCreateBlock } from \"../assemblyBlocks/variable/ArrayCreateBlock\";\n\nimport { BlockType } from \"./BlockType\";\n\n// todo organize imports with index.ts files\n\n\n/**\n * Factory for blocks. In JS because this would be really hard to to in TS :/\n * @param {string} id the id of the corresponding state node.\n * @param {BlockType} type type of block being created\n * @param  {...any} inputs vararg inputs\n * @returns {AbstractBlock} the constructed AbstractBlock from type and inputs.\n */\nexport function createAssemblyBlock(id, type, ...inputs) {\n    let a, b, c, d, e; // declared because of scope limitations\n\n    switch (type) {\n        case BlockType.CLB:\n            [a] = inputs;\n            return new ConsoleLogBlock(id, a); // inputs\n        case BlockType.SUM:\n            [a] = inputs;\n            return new SumBlock(id, a); // inputs\n        case BlockType.PROD:\n            [a] = inputs;\n            return new ProductBlock(id, a); //inputs\n        case BlockType.SUBTRACT:\n            [a] = inputs;\n            return new SubtractBlock(id, a); //inputs\n        case BlockType.MOD:\n            [a] = inputs;\n            return new ModuloBlock(id, a);\n        case BlockType.EXP:\n            [a] = inputs;\n            return new ExponentBlock(id, a);\n        case BlockType.DIV:\n            [a] = inputs;\n            return new DivisionBlock(id, a);\n        case BlockType.CONST:\n            [a] = inputs;\n            return new ConstBlock(id, a); // value\n        case BlockType.VAR_ASSIGN:\n            [a, b] = inputs;\n            return new VarAssignBlock(id, a, b); // name, value\n        case BlockType.VAR_RETRIEVE:\n            [a] = inputs;\n            return new VarRetrieveBlock(id, a); // name\n        case BlockType.DELETE:\n            [a] = inputs;\n            return new VarDeleteBlock(id, a); // name\n        case BlockType.TERNARY:\n            [a] = inputs;\n            return new TernaryBlock(id, a); // inputs\n        case BlockType.AND:\n            [a] = inputs;\n            return new ANDBlock(id, a);\n        case BlockType.OR:\n            [a] = inputs;\n            return new ORBlock(id, a);\n        case BlockType.NOT:\n            [a] = inputs;\n            return new NOTBlock(id, a);\n        case BlockType.EQ:\n            [a] = inputs;\n            return new EQBlock(id, a);\n        case BlockType.GEQ:\n            [a] = inputs;\n            return new GEQBlock(id, a);\n        case BlockType.GT:\n            [a] = inputs;\n            return new GTBlock(id, a);\n        case BlockType.LEQ:\n            [a] = inputs;\n            return new LEQBlock(id, a);\n        case BlockType.LT:\n            [a] = inputs;\n            return new LTBlock(id, a);\n        case BlockType.WHILE:\n            [[a, b]] = inputs;\n            return new WHILEBlock(id, a, b); // conditions, blocks\n        case BlockType.IF:\n            console.log(inputs);\n            [[a, b, c]] = inputs;\n            console.log(a);\n            console.log(b);\n            console.log(c);\n            return new IFBlock(id, a, b, c); // condition, then, otherwise\n        case BlockType.FOR:\n            [a, b, c, d, e] = inputs;\n            return new FORBlock(id, a, b, c, d, e); // counter name, init val, condition, incr value, nodes\n        case BlockType.MAKE_SHAPE:\n            [a, b, c] = inputs;\n            return new MakeShapeBlock(id, a, b, c);\n        case BlockType.MOVE_SHAPE:\n            [a] = inputs;\n            return new MoveBlock(id, a);\n        case BlockType.SCALE_SHAPE:\n            [a] = inputs;\n            return new ScaleBlock(id, a);\n        case BlockType.ROTATE_SHAPE:\n            [a] = inputs;\n            return new RotateBlock(id, a);\n        case BlockType.GET_SHAPE:\n            [a] = inputs;\n            return new GetShapeBlock(id, a);\n        case BlockType.JOY_X:\n            [a] = inputs;\n            return new JoyXStatusBlock(id, a); //name\n        case BlockType.JOY_Y:\n            [a] = inputs;\n            return new JoyYStatusBlock(id, a); //name\n        case BlockType.BTN_STATUS:\n            [a] = inputs;\n            return new ButtonStatusBlock(id, a); //name\n        case BlockType.ARR_CREATE:\n            [a] = inputs;\n            return new ArrayCreateBlock(id, a);\n        case BlockType.ARR_SET_IX:\n            [a, b] = inputs;\n            return new ArraySetIndex(id, a, b);\n        case BlockType.ARR_GET_IX:\n            [a, b] = inputs;\n            return new ArrayGetIndex(id, a, b);\n        case BlockType.MAKE_CONTROL_ELEM:\n            [a, b, c] = inputs;\n            return new MakeControlElementBlock(id, a, b, c);\n        case BlockType.GET_X:\n            [a] = inputs;\n            return new GetXBlock(id, a);\n        case BlockType.GET_Y:\n            [a] = inputs;\n            return new GetYBlock(id, a);\n        default:\n            throw new EvalError('Entered BlockType is not yet supported in BlockFactory');\n    }\n}","export * from './CustomNode';\nexport * from './FunctionNode';\nexport * from './GuranteedRoot';\nexport * from './IfNode';\nexport * from './InputNode';\nexport * from './NodeData';\nexport * from './OutputNode';\nexport * from './WhileNode';\n"],"sourceRoot":""}